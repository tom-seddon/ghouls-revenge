                .include "gcommon.s65"

;-------------------------------------------------------------------------

                .if editor
*=$00
ed_zp_begin:
                .dsection ed_zp
ed_zp_end:
                .cerror *>$70,'ed_zp overflow'
                .endif
                
;-------------------------------------------------------------------------

player_addr=$70

; screen address for writing sprite
L0072=$72

; screen address for writing sprite row 1
L0074=$74
L0075=$75
L0076=$76
L0077=$77

; data address for row 0 of player sprite
L0078=$78
L0079=$79
was_platform_addr=$7a
L007C=$7c
L007E=$7e
L007F=$7f
was_conveyor_addr=$80               ; Crap name, since it doesn't even
                                ; convey! I njust oticed too late that
                                ; the objects page calls this the
                                ; moving floor
object_addr=$82
level_draw_ptr=$84
;L0084=$84
L0085=$85
level_draw_screen_addr=$86
                
;-------------------------------------------------------------------------

max_num_objects=85
*=$900
object_types:
                .fill max_num_objects
object_addrs_lo:
                .fill max_num_objects
object_addrs_hi:
                .fill max_num_objects
object_var0s:
                .fill max_num_objects
object_var1s:
                .fill max_num_objects
object_var2s:
                .fill max_num_objects
                .cerror *>$b00,format('object tables overflow')
                
;-------------------------------------------------------------------------

                .if editor
*=gedmc_org
                .else
*=gmc_org
                .endif

;-------------------------------------------------------------------------

gmc_start:
                
                .if editor
                ; C64 files don't have separate load and exec
                ; addresses.
                jmp ed_entry
                .endif

sprite_blank:
                .fill 16,0
sprite_block:
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %11111111
                .byte %10001000
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %10001000
                .byte %11111111
sprite_lblock:
                .byte %11111111
                .byte %10011001
                .byte %01110111
                .byte %01100110
                .byte %00100010
                .byte %00110011
                .byte %00010001
                .byte %00000000
                .byte %11111111
                .byte %10001000
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %10001000
                .byte %01110111
sprite_rblock:
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %11111111
                .byte %10011001
                .byte %11101110
                .byte %01100110
                .byte %01000100
                .byte %11001100
                .byte %10001000
                .byte %00000000
sprite_spikes:
                .byte %00001001
                .byte %00001001
                .byte %00001001
                .byte %00001101
                .byte %00001101
                .byte %00000101
                .byte %00000101
                .byte %00001111
                .byte %00001001
                .byte %00001001
                .byte %00001001
                .byte %00001011
                .byte %00001011
                .byte %00001010
                .byte %00001010
                .byte %00001111
sprite_spring_row0:
                .byte %00001010
                .byte %00001111
                .byte %00000000
                .byte %00000111
                .byte %00001000
                .byte %00000111
                .byte %00000000
                .byte %00000111
                .byte %00001010
                .byte %00001100
                .byte %00000010
                .byte %00001001
                .byte %00000101
                .byte %00001110
                .byte %00000010
                .byte %00001001
sprite_spring_row1:
                .byte %00001000
                .byte %00000111
                .byte %00000000
                .byte %00000111
                .byte %00001000
                .byte %00000111
                .byte %00001000
                .byte %00000111
                .byte %00000101
                .byte %00001110
                .byte %00000010
                .byte %00001001
                .byte %00000101
                .byte %00001110
                .byte %00000001
                .byte %00001110
sprite_dots:
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00110000
                .byte %00110000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00110000
                .byte %00110000
                .byte %00000000
                .byte %00000000
                
sprite_pl_right_0:.byte 0, $30, $70, $50,$F0,$E0,$F0, $70, 0, 0, $80,$C0, $80, 0, 0,$C0, $70, $30, $30, $20, $20,$C0, $80, 0, $80, 0, $80, $80,$C0, $80, 0, 0; 0
sprite_pl_right_1:.byte 0, 0, $10, $10, $30, $30, $30, $10, 0,$C0,$E0, $60,$F0, $80,$F0,$E0, $10, 0, 0, 0, 0, 0, 0, 0,$E0,$C0,$C0,$C0,$C0, $80, $80,$C0; 0
sprite_pl_left_0:.byte 0, 0, $10, $30, $10, 0, 0, $30, 0,$C0,$E0,$A0,$F0, $70,$F0,$E0, $10, 0, $10, $10, $30, $10, 0, 0,$E0,$C0,$C0, $40, $40, $30, $10, 0; 0
sprite_pl_left_1:.byte 0, $30, $70, $60,$F0, $10,$F0, $70, 0, 0, $80, $80,$C0,$C0,$C0, $80, $70, $30, $30, $30, $30, $10, $10, $30, $80, 0, 0, 0, 0, 0, 0, 0; 0
sprite_pl_facing:.byte $10, $30, $10, $70, $40, $60, $30, $30, $80,$C0, $80,$E0, $20, $60,$C0,$C0, $10, $20, $20, $20, $20, $20, $20, $60, $80, $40, $40, $40, $40, $40, $40, $60; 0
sprite_spider_0_row0:.byte 0, 0, 1, 3, $11, 3, 6, $37, 0, 0, $6E, $77, $77,$FF,$DF,$DF, 0, 0, $67,$EE,$EE,$FF,$BF,$BF, 0, 0, 8, $C, $88, $C, 6,$CE; 0
sprite_spider_0_row1:.byte $33, $13, $17, $15, 5, 1, 0, 0, $57, $77, $77, 2, 2, 9, 8, 8,$AE,$EE,$EE, 4, 4, 9, 1, 1,$CC, $8C, $8E, $8A, $A, 8, 0, 0; 0
sprite_floating_platform:.byte $FF,$FF, $9E, $9E, $56, 7, 8, 8,$FF,$CF,$C3,$CF,$DE, $2C, $1E, 3,$FF, $3F, $3C, $3F,$B7, $43, $87, $C,$FF,$FF, $97, $97,$A6, $E, 1, 1; 0
sprite_goal_row0:.byte $10,$50, $60,$F0, $58, $1E, $F, $F, $20,$D0,$F0,$A0, $70,$D0, $F, $3C, $50,$E0,$B0,$D0, $70,$A0, $F, $87, 0,$C0,$A0, $70,$C1, $87, $F, $F; 0
sprite_goal_row1:.byte $3F, $5C, $6C, $5C, $3F, $F, 7, 1, $3C,$BD,$BD,$BC, $3C, $2D, $2D, $F,$C3,$DB,$DB,$D3, $87, $F, $F, $F,$CF,$A3, $63,$A3,$CF, $F, $E, 8; 0
sprite_conveyor:.byte 0, 0, 0, 0, 0, 0, 0, 0,$FF,$AA, $55, $55,$AA,$AA,$FF, 0; 0
sprite_pl_die_8:.byte 0, $40, $20,$C0, 0, $20, $50, $10, $80,$A0, $40, 0, $30, $40, $20, 0; 0
sprite_pl_splat:.byte 0, 0, 0, $20, $90, $70,$E0,$F0, 0, 0, 0, $40,$C0,$A0,$D0,$F0; 0
sprite_spider_1_row0:.byte $C, $17, $11, 0, $17, $C, $33, $77, 0, 0,$CC, $55,$FF,$FF,$DF,$DF, 0, 0, $33,$AA,$FF,$FF,$BF,$BF, 3, $8E, $88, 0, $8E, 3,$CC,$EE; 0
sprite_spider_1_row1:.byte $55, $5D, $19, $1B, $A, 2, 2, 2, $57, $77, $77, 2, 2, 4, 4, 0,$AE,$EE,$EE, 4, 4, 2, 2, 0,$AA,$AB, $89, $8D, 5, 4, 4, 4; 0
sprite_power_pill:.byte 0, 0, $10, $21, $21, $21, $10, 0, 0, 0, $80, $48, $48, $48, $80, 0; 0
sprite_ghost_angry_row0:.byte 3, 7, 7, $69, $49, $49, $F, $F, $C, $E, $E, $69, $29, $29, $F, $F; 0
sprite_ghost_angry_row1:.byte $E, 4, 4, 5, 3, 3, 3, $F, 7, 3, 2, $A, $E, $C, $C, 0; 0
sprite_ghost_happy_row0:.byte 3, 7, 7, $49, $49, $69, $F, $F, $C, $E, $E, $29, $29, $69, $F, $F; 0
sprite_ghost_happy_row1:.byte $D, 5, 4, 6, 3, $B, $F, 7, $B, $B, 2, 6, $E, $C, $C, 8; 0
sprite_pl_die_0:.byte $10, $30, $30, $70, $70, $30, $30, $10, $80,$C0,$C0,$E0,$E0,$C0,$C0, $80; 0
sprite_pl_die_1:.byte 0, $20, $20, $60, $70, $30, $30, $10, 0, $40, $40, $60,$E0,$C0,$C0, $80; 0
sprite_pl_die_2:.byte 0, 0, $40, $60, $70, $30, $30, $10, 0, 0, $20, $60,$E0,$C0,$C0, $80; 0
sprite_pl_die_3:.byte 0, 0, 0, 0, $70, $30, $30, $10, 0, 0, 0, 0,$E0,$C0,$C0, $80; 0
sprite_pl_die_4:.byte 0, 0, 0, 0, $30, $70, $30, $10, 0, 0, 0, 0,$C0,$E0,$C0, $80; 0
sprite_pl_die_5:.byte 0, 0, 0, 0, $10, $10, $10, $10, 0, 0, 0, 0, $80, $80, $80, $80; 0
sprite_pl_die_6:.byte 0, 0, 0, 0, $10, $10, 0, 0, 0, 0, 0, 0, $80, $80, 0, 0; 0
sprite_pl_die_7:.byte 0, 0, $20, $10, $10, $20, 0, 0, 0, 0, $40, $80, $80, $40, 0, 0; 0
sprite_alt_goal_row1:.byte $69, $3C, $3C, $69, $F, $F, 7, 0, $3E, $2F, $2F, $3F, $3E, $2F, $2D, $F,$C7, $4F, $4F,$CB, $87, $F, $F, $F, $69,$C3,$C3, $69, $F, $F, $E, 0; 0

envelope: .macro n,len,pcr1,pcr2,pcr3,pl1,pl2,pl3,aacr,dacr,sacr,racr,atl,dtl
                .byte \n
                .char \len
                .char \pcr1,\pcr2,\pcr3
                .byte \pl1,\pl2,\pl3
                .char \aacr,\dacr,\sacr,\racr
                .char \atl,\dtl
                .endmacro
                
envelopes:
                .envelope 1,1,0,0,0,0,0,200,0,0,0,-2,126,0
                .envelope 2,2,1,-1,1,2,4,2,1,0,0,-1,100,0
                .envelope 3,3,20,-20,8,5,5,5,0,0,0,-1,110,0
                .envelope 4,2,0,0,0,0,0,255,3,0,0,-126,127,0 
                
; footstep
L0AC0:
                .word $11       ; channel
                .word $FFF1     ; amplitude
                .word $FF       ; pitch
                .word 0         ; duration

; jump?
L0AC8:                         
                .word $10; channel
                .word 1         ; amplitude
                .word 2         ; pitch
                .word 1         ; duration
; low beep
L0AD0:
                .word $13; channel
                .word $FFF1     ; amplitude
                .word 0         ; pitch
                .word 3         ; duration

; spooky background noise
L0AD8:
                .word $12; channel
                .word 2         ; amplitude
                .word 5         ; pitch
                .word $32       ; duration

; dot eaten
L0AE0:
                .word $13; channel
                .word 3         ; amplitude
                .word $30       ; pitch
                .word 5         ; duration
                .byte 0
                .byte 0
bonus_update_timer:.byte 2
;spider_speed: .byte $C
;spider_update_timer: .byte $4D
;spider_direction: .byte 1
L0AEE: .byte 0                  ;some kind of sound timer
;conveyor_direction: .byte 1
;conveyor_update_timer: .byte $4D
L0AF1: .byte 1                  ;update timer of some kind
L0AF2: .byte $3C
L0AF3: .byte 0                  ;unused???
L0AF4: .byte $85
platform_speed:.byte 6
             .byte 1
L0AF7: .byte $B0,$72            ;backup of player sprite address
;platform_update_timer:.byte 1
;platform_direction: .byte 0
player_update_timer:.byte 2
L0AFC: .byte 0                  ;???
player_movement:.byte 2
player_jump_state:.byte 0
player_anim_frame:.byte 0

update_object_index: .byte 0

level_finished: .byte 0
                
ghosts_table:   .word $6A28
                .word 0
                .word 0
                .word 0
                .byte $48       ; H

; type_chars:
;                 .byte ' '       ;blank
;                 .byte $e2       ;lblock
;                 .byte $e3       ;rblock
;                 .byte $e0       ;block
;                 .byte 

;-------------------------------------------------------------------------

num_objects:
                .byte 0
                
;-------------------------------------------------------------------------

reset_envelopes: .block
                ; level_draw_ptr safe to reuse
                lda #<envelopes
                sta level_draw_ptr
                lda #>envelopes
                sta level_draw_ptr+1

                ldx #4

loop:
                txa
                pha
                
                ldx level_draw_ptr+0
                ldy level_draw_ptr+1
                lda #8          ;define envelope
                jsr osword

                clc
                lda level_draw_ptr+0
                adc #14
                sta level_draw_ptr+0
                bcc +
                inc level_draw_ptr+1
+

                pla
                tax
                dex
                bne loop
                
                rts
                .endblock

;-------------------------------------------------------------------------

make_otype: .function ltypes_begin,ltypes_end,sprite_data,sprite_width,sprite_height,init_routine,update_routine,ed_flags
                .cerror !(sprite_width==1||sprite_width==2),'invalid sprite width'
                .cerror !(sprite_height==1||sprite_height==2),'invalid sprite height'
                
_otype_flags:=0
                .if sprite_width==2
_otype_flags:=_otype_flags|otype_flags_width2
                .endif

                .if sprite_height==2
_otype_flags:=_otype_flags|otype_flags_height2
                .endif

                .endfunction {.ltypes_begin:ltypes_begin,.ltypes_end:ltypes_end,.sprite_data:sprite_data,.otype_flags:_otype_flags,.init_routine:init_routine,.update_routine:update_routine,.ed_flags:ed_flags}

make_sta_otype: .function ltype,sprite_data,sprite_width,sprite_height,ed_flags=0
                .endfunction make_otype(ltype,ltype+1,sprite_data,sprite_width,sprite_height,0,0,ed_flags)

make_dyn_otype: .function base_ltype,num_ltypes,sprite_data,sprite_width,sprite_height,init_routine,update_routine,ed_flags=0
                .endfunction make_otype(base_ltype,base_ltype+num_ltypes,sprite_data,sprite_width,sprite_height,init_routine,update_routine,ed_flags)

_:=[]
_..=[make_sta_otype(type_blank.index,0,1,1,ed_flags_repeat)]
_..=[make_sta_otype(type_lblock.index,sprite_lblock,1,1)]
_..=[make_sta_otype(type_rblock.index,sprite_rblock,1,1)]
_..=[make_sta_otype(type_block.index,sprite_block,1,1,ed_flags_repeat)]
_..=[make_sta_otype(type_spikes.index,sprite_spikes,1,1)]
_..=[make_sta_otype(type_spring_1_row.index,sprite_spring_row0,1,1)]
_..=[make_sta_otype(type_spring_2_rows.index,sprite_spring_row0,1,2)]
_..=[make_sta_otype(type_dots.index,sprite_dots,1,1,ed_flags_repeat)]
_..=[make_sta_otype(type_pill.index,sprite_power_pill,1,1)]
otype_conveyor=len(_)           ;temp
_..=[make_dyn_otype(type_conveyor.index,num_speeds,sprite_conveyor,1,1,0,update_conveyor)]
otype_platform=len(_)           ;temp
_..=[make_dyn_otype(type_platform.index,num_speeds,sprite_floating_platform,2,1,0,update_platform)]
otype_spider=len(_)             ;temp
_..=[make_dyn_otype(type_spider.index,num_speeds,sprite_spider_0_row0,2,2,0,update_spider)]
_..=[make_dyn_otype(type_spider2.index,num_speeds,sprite_spider_0_row0,2,2,0,update_spider,ed_flags_masked)]
otypes=_

otypes_ltype_begin:
                .byte otypes.ltypes_begin
otypes_ltype_end:
                .byte otypes.ltypes_end
otypes_sprite_data_lo:
                .byte <otypes.sprite_data
otypes_sprite_data_hi:
                .byte >otypes.sprite_data
otypes_init_routine_lo:
                .byte <otypes.init_routine
otypes_init_routine_hi:
                .byte >otypes.init_routine
otypes_update_routine_lo:
                .byte <otypes.update_routine
otypes_update_routine_hi:
                .byte >otypes.update_routine
otypes_otype_flags:
                .byte otypes.otype_flags
otypes_ed_flags: .proc
                .byte otypes.ed_flags
                .endproc

;-------------------------------------------------------------------------
                
entry_init_level: .block
game_start_y=4
game_start_addr=$5800+game_start_y*320
level_name_y=28

                stx go

                lda #0
                sta num_objects
                ; sta conveyor_addr+1
                ; sta spider_addr+1
                ; sta platform_addr+1
                
                lda #31
                jsr oswrch
                lda #0
                jsr oswrch
                lda #game_start_y
                jsr oswrch

                lda #<game_start_addr
                sta level_draw_screen_addr+0
                lda #>game_start_addr
                sta level_draw_screen_addr+1

                lda #$ff
                sta colour

                lda #<-(level_width*level_height)
                sta counter+0
                lda #>-(level_width*level_height)
                sta counter+1

loop:
                ldy #LevelData.map ;get the addition for free...
                lda (level_draw_ptr),y

                ldx #0
find_loop:
                ldy item_info,x
                cpy #$ff
                beq not_found
                
                cmp item_info,x
                beq found

                inx
                inx
                inx
                jmp find_loop

not_found:
                cmp #type_spring_2_rows.index
                beq spring_2_rows
                
                cmp #type_pill.index
                beq pill

                cmp #type_conveyor.index
                beq conveyor

                cmp #type_platform.index
                bcc +
                cmp #type_platform.index+num_speeds
                bcc platform
+
                
                cmp #type_spider.index
                bcc +
                cmp #type_spider.index+num_speeds
                bcc spider
+

                cmp #type_spider2.index
                bcc +
                cmp #type_spider2.index+num_speeds
                bcc spider2
+
                
next:
                ; pretend it was blank.
                ldx #0
                
found:
                lda #17
                jsr oswrch
                lda item_info+1,x
                jsr oswrch
                lda item_info+2,x
                jsr oswrch

                inc level_draw_ptr+0
                bne +
                inc level_draw_ptr+1
+
                
                clc
                lda level_draw_screen_addr+0
                adc #16
                sta level_draw_screen_addr+0
                bcc +
                inc level_draw_screen_addr+1
+

                inc counter+0
                bne loop
                inc counter+1
                bne loop
                
done:
; The BASIC code ends up clearing a bunch of extra stuff due to
; slightly careless-looking use of !.
                lda #0
                sta object_addr+2
                sta object_addr+3
                sta object_addr+4
                sta was_platform_addr+2
                sta was_platform_addr+3
                sta was_platform_addr+4
                rts

spring_2_rows:
                ldx #0
spring_2_rows_loop:
                lda spring_2_rows_data,x
                jsr oswrch
                inx
                cpx #size(spring_2_rows_data)
                bne spring_2_rows_loop
                jmp next
spring_2_rows_data: .block
                .text 17,1,$e1,8,10,$e5,11,8
                .endblock
                
platform:
                ldy #otype_platform
                jsr add_object
                sec
                sbc #type_platform.index
                sta object_var1s,x ;speed
                sta object_var2s,x ;update timer
                lda #0
                sta object_var0s,x ;direction
                jmp next
                
conveyor:
                ldy #otype_conveyor
                jsr add_object
                lda #2
                sta object_var2s,x ;update timer
                lda #1
                sta object_var0s,x ;direction
                jmp next
                
pill:
                ldy #15
pill_loop:
                lda sprite_power_pill,y
                sta (level_draw_screen_addr),y
                dey
                bpl pill_loop
                jmp next

spider2:
                ldx go
                beq next
                sec
                sbc #type_spider2.index
                jmp spider_common
                
spider:
                sec
                sbc #type_spider.index
spider_common:
                ldy #otype_spider
                jsr add_object
                sta object_var1s,x ;speed
                sta object_var2s,x ;update timer
                lda #1
                sta object_var0s,x ;direction
                jmp next

add_object:
                pha
                
                ldx num_objects
                cpx #max_num_objects
                bne +
                
                ; oops! maxed out. reuse the last slot.
                dex
                stx num_objects
+
                inc num_objects

                tya
                sta object_types,x
                lda level_draw_screen_addr+0
                sta object_addrs_lo,x
                lda level_draw_screen_addr+1
                sta object_addrs_hi,x

                pla
                rts
                
go:
                .byte 0
colour:
                .byte 0
counter:
                .word 0
                .endblock

item_info_entry: .macro item
                .byte \item.index,\item.colour,\item.char
                .endmacro
                
item_info:
                .item_info_entry type_blank
                .item_info_entry type_lblock
                .item_info_entry type_rblock
                .item_info_entry type_block
                .item_info_entry type_spikes
                .item_info_entry type_dots
                .item_info_entry type_spring_1_row
                .byte $ff

; C=0 on exit if found. X refers to item info table entry.
find_item_info: .proc
                ldx #0
loop:
                ldy item_info,x
                cpy #$ff
                beq not_found
                cmp item_info,x
                beq found
                inx
                inx
                inx
                jmp loop
found:
                clc
not_found:
                rts
                .endproc
                
;-------------------------------------------------------------------------

; copy of what was behind player
L0DDE:
                .fill 32

;-------------------------------------------------------------------------

                .byte 0
                .byte 0
bonus_chars:    .byte 234, 238; 0
                .byte 'E'
                .byte 'S'
                .byte 'T'
                .byte 'S'
                .byte 134
                .byte '1'
                .byte 'G'
                .byte 'H'
                .byte 'O'
                .byte 'S'
                .byte 'T'
                .byte ' '
                .byte ' '
                .byte '$'
score_chars:    .byte 230, 230, 230, 238, 232; 0
                .byte ' '
                .byte ' '
                .byte '$'
                .byte 'R'
                .byte 'O'
                .byte 'B'
                .byte 'O'
                .byte 'T'
                .byte ' '
L0E1E:       .byte ' '
                .byte '$'

;-------------------------------------------------------------------------

entry_game:
                lda #1
                ; sta spider_direction
                ; sta conveyor_direction
                sta player_anim_frame
                lda #0
                sta level_finished
                sta L0AEE
                sta player_jump_state
                ; sta platform_direction
                sta L0AF3
                lda #2
                sta player_movement
                sta player_update_timer
                ; sta platform_update_timer
                sta L0AF1
                ; sta conveyor_update_timer
                ; sta spider_update_timer
                lda #$1F
                sta bonus_update_timer

main_loop:
                ; TODO what is this? random number type of thing?
                lda L0AF4
                adc player_addr
                adc was_platform_addr
                adc L007C
                sta L0AF4
                jsr update_player
                jsr L1205

                ldx #$ff
                
update_objects_loop:
                inx
                cpx num_objects
                beq update_objects_done

                stx update_object_index
                
                lda object_addrs_lo,x
                sta object_addr+0
                lda object_addrs_hi,x
                sta object_addr+1
                
                ldy object_types,x
                
                lda otypes_update_routine_lo,y
                sta jsr_object_update+1
                lda otypes_update_routine_hi,y
                sta jsr_object_update+2

jsr_object_update: jsr $ffff

                ldx update_object_index
                lda object_addr+0
                sta object_addrs_lo,x
                lda object_addr+1
                sta object_addrs_hi,x

                jmp update_objects_loop
update_objects_done:
                ; jsr update_platform
                ; jsr update_conveyor
                ; jsr update_spider
                
                lda #$81        ; INKEY (AUG p153)
                ldx #$C8        ; P
                ldy #$FF        ; keyboard scan
                jsr osbyte
                tya             ; A=$ff if pressed
                beq L0E85

pause_loop:
                lda #$81        ; INKEY (AUG p153)
                ldx #$C9        ; O
                ldy #$FF        ; keyboard scan
                jsr osbyte
                tya
                beq pause_loop

L0E85:
                lda #19
                jsr osbyte

                lda #$81        ; INKEY (AUG p153)
                ldx #$8F        ; ESCAPE
                ldy #$FF        ; keyboard scan
                jsr osbyte
                tya
                beq main_loop
                rts

;-------------------------------------------------------------------------

update_player: .block

                dec player_update_timer
                lda player_update_timer
                beq L0EA8
                rts

;-------------------------------------------------------------------------

L0EA8:
                lda #2
                sta player_update_timer
                dec bonus_update_timer
                lda bonus_update_timer
                bne L0EBD
                lda #$1F
                sta bonus_update_timer
                jsr update_bonus

L0EBD:
                lda player_addr
                sta L0072
                sta L0AF7
                clc
                adc #$40
                sta L0074
                lda player_addr+1
                sta L0072+1
                sta L0AF7+1
                adc #1
                sta L0075
                jmp L1521
                .endblock

;-------------------------------------------------------------------------

L0ED7:
                jmp L1490

;-------------------------------------------------------------------------

L0EDA:
                lda #0
                sta player_movement
                lda #$81
                ldx #$BD        ; X
                ldy #$FF
                jsr osbyte
                tya
                beq test_z_key
; X pressed
                lda player_movement
                bne L0EF8
                lda #<sprite_pl_right_0
                sta L0078
                lda #>sprite_pl_right_0
                sta L0079

L0EF8:
                lda #1          ; 1=right
                sta player_movement
                jmp L0F1E

;-------------------------------------------------------------------------

test_z_key:
                lda #$81
                ldx #$9E        ; Z
                ldy #$FF
                jsr osbyte
                tya
                beq L0F1E
                lda player_movement
                bne L0F19
                lda #<sprite_pl_left_0
                sta L0078
                lda #>sprite_pl_left_0
                sta L0079

L0F19:
                lda #2          ; 2=left
                sta player_movement

L0F1E:
                lda player_movement
                bne L0F2E
                lda #<sprite_pl_facing
                sta L0078
                lda #>sprite_pl_facing
                sta L0079
                jmp L1158

;-------------------------------------------------------------------------

L0F2E:
                lda player_anim_frame
                eor #1
                sta player_anim_frame
                bne L0F51
; select next anim frame sprite
                lda L0078
                clc
                adc #$20
                sta L0078
                lda L0079
                adc #0
                sta L0079
                lda #7
                ldx #<L0AC0
                ldy #>L0AC0
                jsr osword
                jmp L1158

;-------------------------------------------------------------------------

L0F51:
                lda player_movement
                cmp #2
                beq move_player_left; taken if moving left
                cmp #1
                bne L0F89     ; taken if stationary
; moving right
                lda player_addr
                clc
                adc #8
                sta player_addr
                lda player_addr+1
                adc #0
                sta player_addr+1
                lda #<sprite_pl_right_0
                sta L0078
                lda #>sprite_pl_right_0
                sta L0079
                jmp L0F89

;-------------------------------------------------------------------------

move_player_left:
                lda player_addr
                sec
                sbc #8
                sta player_addr
                lda player_addr+1
                sbc #0
                sta player_addr+1
                lda #<sprite_pl_left_0
                sta L0078
                lda #>sprite_pl_left_0
                sta L0079

L0F89:
                ldy #$F

L0F8B:
                lda L0DDE,y  ; copy of what was under player, row 0?
                sta (L0072),y
                lda L0DDE+16,y  ; copy of what was under player, row 1?
                sta (L0074),y
                dey
                bpl L0F8B
                lda L0DDE+5  ; copy of what was under player, row 0?
                cmp #$21
                bne L101C
                lda L0DDE+$C ; copy of what was under player, row 0?
                cmp #$48
                bne L101C
                lda #6
                sta L0AC8+4  ;pitch
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword
                lda #2
                sta L0AC8+4  ;pitch
                ldy #$F
                lda #0

L0FBF:
                sta (L0072),y
                sta L0DDE,y  ; copy of what was under player, row 0?
                dey
                bne L0FBF
                lda #100
                sta L0AEE
                ldx #100
                jsr add_X_to_score
                lda #4
                sta L0AF4    ; ghost index

erase_ghosts_loop:
                ldy L0AF4
                lda ghosts_table,y
                sta L0072
                lda ghosts_table+1,y
                sta L0072+1
                beq erase_ghosts_next; taken if no ghost
                lda L0072
; form screen address for ghost row 1
                clc
                adc #$40
                sta L0074
                lda L0072+1
                adc #1
                sta L0075
                ldy #$F

erase_ghost_loop:
                lda (L0072),y
                cmp sprite_ghost_angry_row0,y
                bne erase_ghost_row1
                lda #0
                sta (L0072),y

erase_ghost_row1:
                lda (L0074),y
                cmp sprite_ghost_angry_row1,y
                bne erase_ghost_next
                lda #0
                sta (L0074),y

erase_ghost_next:
                dey
                bpl erase_ghost_loop

erase_ghosts_next:
                dec L0AF4
                dec L0AF4
                lda L0AF4
                cmp #$FE
                bne erase_ghosts_loop

L101C:
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                lda player_jump_state
                bne L1060
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L103D:
                lda (L0072),y
                cmp #$FF
                beq L104B
                dey
                bpl L103D
                jmp L1082

;-------------------------------------------------------------------------

L104B:
                lda player_addr
                sec
                sbc #$40
                sta player_addr
                lda player_addr+1
                sbc #1
                sta player_addr+1
                ldx #5
                jsr add_X_to_score
                jmp L1082

;-------------------------------------------------------------------------

L1060:
                lda L0072
                clc
                adc #$40
                sta L0072
                lda L0072+1
                adc #1
                sta L0072+1
                ldy #0
                lda (L0072),y
                cmp #$FF
                beq L107D
                ldy #8
                lda (L0072),y
                cmp #$FF
                bne L1082

L107D:
                lda #0
                sta player_jump_state

L1082:
                ldy #$F
                lda (L0074),y
                cmp #$F0
                bne L1092
                lda player_jump_state
                bne L1092
                jmp L158E

;-------------------------------------------------------------------------

L1092:
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L10A1:
                lda (player_addr),y
                sta L0DDE,y  ; copy of what was under player, row 0?
                lda (L0072),y
                sta L0DDE+16,y  ; copy of what was under player, row 1?
                dey
                bpl L10A1
                lda L0DDE+4  ; copy of what was under player, row 0?
                cmp #$30
                bne L10DD
                lda #0
                sta L0DDE+4  ; copy of what was under player, row 0?
                sta L0DDE+5  ; copy of what was under player, row 0?
                lda L0085
                clc
                adc #4
                sta L0085
                lda L0085
                sta L0AE0+4  ;pitch
                lda #7
                ldx #<L0AE0
                ldy #>L0AE0
                jsr osword
                clc
                ldx #3
                jsr add_X_to_score
                jmp L10E6

;-------------------------------------------------------------------------

L10DD:
                lda player_anim_frame
                bne L10E6
                lda #0
                sta L0085

L10E6:
                ldy #$F

L10E8:
                lda L0DDE+16,y  ; copy of what was under player, row 1?
                cmp #8
                beq L1104
                cmp #1
                beq L1104
                lda L0DDE,y  ; copy of what was under player, row 0?
                cmp #8
                beq L1104
                cmp #1
                beq L1104
                dey
                bne L10E8
                jmp L1131

;-------------------------------------------------------------------------

L1104:
                ldy #$F
                lda #0

L1108:
                sta L0DDE+16,y  ; copy of what was under player, row 1?
                sta L0DDE,y  ; copy of what was under player, row 0?
                dey
                bpl L1108
                lda L0AF7
                sta player_addr
                lda L0AF7+1
                sta player_addr+1
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword
                lda player_anim_frame
                eor #1
                sta player_anim_frame
                jmp L1082

;-------------------------------------------------------------------------

L1131:
                ldy #$F

L1133:
                lda (player_addr),y
                beq L114B
                cmp #$10
                bcs L114B

L113B:
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                jmp L16B4

;-------------------------------------------------------------------------

L114B:
                lda (L0072),y
                beq L1153
                cmp #$10
                bcc L113B

L1153:
                dey
                bpl L1133

L1158:
                lda L0078
                clc
                adc #$10
                sta L0074
                lda L0079
                adc #0
                sta L0075
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L1174:
                lda (player_addr),y
                beq L117F
                cmp #$F
                bcs L117F

L117C:
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L117F:
                lda (L0072),y
                beq L1187
                cmp #$F
                bcc L117C

L1187:
                dey
                bpl L1174
                ldy #$F

L118E:
                lda (L0078),y
                sta (player_addr),y
                lda (L0074),y
                sta (L0072),y
                dey
                bpl L118E
                rts

;-------------------------------------------------------------------------

update_platform:       .block
                ; lda platform_addr+1
                ; beq L11A9       ;skip if no platform
                dec object_var2s,x ; platform_update_timer
                beq L11AA       ;taken if time to update platform

L11A9:
                rts

;-------------------------------------------------------------------------

L11AA:
                lda object_var1s,x;platform_speed
                sta object_var2s,x;platform_update_timer
                ldy #$1F
                lda #0

L11B4:
                sta (object_addr),y
                dey
                bpl L11B4

L11BB:
                lda object_var0s,x;platform_direction
                jsr object_addr_left_or_right
                
                ldy #$1F

L11DF:
                lda (object_addr),y

                ; Change dir if bumping into wall
                cmp #$FF
                beq change_platform_direction

                ; Change dir if bumping into left border
                cmp #$08                      
                beq change_platform_direction

                ; Change dir if bumping into right border
                cmp #$01
                beq change_platform_direction
                
                dey
                bpl L11DF
                jmp draw_floating_platform

;-------------------------------------------------------------------------

change_platform_direction:
                lda object_var0s,x
                eor #1
                sta object_var0s,x
                jmp L11BB
                .endblock

;-------------------------------------------------------------------------

draw_floating_platform:
                ldy #$1F

L11FA:
                lda sprite_floating_platform,y
                sta (object_addr),y
                dey
                bpl L11FA
                rts

;-------------------------------------------------------------------------

L1205:       .block

                dec L0AF1
                lda L0AF1
                beq L1210
                jmp L1386

;-------------------------------------------------------------------------

L1210:
                lda L0AEE
                cmp #$55
                bcc L1237
                dec L0AEE
                lda L0AEE
                sta L0AD8+4  ;pitch
                lda #7
                ldx #<L0AD8
                ldy #>L0AD8
                jsr osword
                lda L0AF2
                sta L0AF1
                ldx #5
                jsr add_X_to_score
                jmp L1386

;-------------------------------------------------------------------------

L1237:
                lda #4
                sta L0AF1

L123C:
                ldy L0AF1
                lda ghosts_table,y
                sta L007E
                lda ghosts_table+1,y
                sta L007F
                lda L007E
                sta L0072
                lda L007F
                sta L0072+1
                bne L1256
                jmp L1370

;-------------------------------------------------------------------------

L1256:
                lda L007E
                sec
                sbc #$80
                sta L0074
                lda L007F
                sbc #0
                sta L0075
                lda player_addr
                sec
                sbc #$80
                sta L0076
                lda player_addr+1
                sbc #0
                sta L0077

L1270:
                lda L0074
                cmp #$40
                lda L0075
                sbc #1
                bcc L128A
                lda L0074
                sec
                sbc #$40
                sta L0074
                lda L0075
                sbc #1
                sta L0075
                jmp L1270

;-------------------------------------------------------------------------

L128A:
                lda L0076
                cmp #$40
                lda L0077
                sbc #1
                bcc L12A4
                lda L0076
                sec
                sbc #$40
                sta L0076
                lda L0077
                sbc #1
                sta L0077
                jmp L128A

;-------------------------------------------------------------------------

L12A4:
                lda L0074
                cmp L0076
                bne L12AB
                clc

L12AB:
                lda L0075
                sbc L0077
                bcc L12C1
                lda L007E
                sec
                sbc #8
                sta L007E
                lda L007F
                sbc #0
                sta L007F
                jmp L1301

;-------------------------------------------------------------------------

L12C1:
                lda L0074
                cmp L0076
                beq L12D7
                lda L007E
                clc
                adc #8
                sta L007E
                lda L007F
                adc #0
                sta L007F
                jmp L1301

;-------------------------------------------------------------------------

L12D7:
                lda L007E
                cmp player_addr
                bne L12DE
                clc

L12DE:
                lda L007F
                sbc player_addr+1
                bcc L12F4
                lda L007E
                sec
                sbc #$40
                sta L007E
                lda L007F
                sbc #1
                sta L007F
                jmp L1301

;-------------------------------------------------------------------------

L12F4:
                lda L007E
                clc
                adc #$40
                sta L007E
                lda L007F
                adc #1
                sta L007F

L1301:
                lda L0072
                clc
                adc #$40
                sta L0074
                lda L0072+1
                adc #1
                sta L0075
                ldy #$F

L1310:
                lda (L0072),y
                cmp sprite_ghost_angry_row0,y
                bne L131B
                lda #0
                sta (L0072),y

L131B:
                lda (L0074),y
                cmp sprite_ghost_angry_row1,y
                bne L1326
                lda #0
                sta (L0074),y

L1326:
                dey
                bpl L1310
                lda L007E
                clc
                adc #$40
                sta L0074
                lda L007F
                adc #1
                sta L0075
                ldy #$F

L133A:
                lda (L007E),y
                cmp #$20
                bne L1343
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L1343:
                cmp #0
                bne L134C
                lda sprite_ghost_angry_row0,y
                sta ($7E),y

L134C:
                lda (L0074),y
                cmp #$20
                bne L1355
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L1355:
                cmp #0
                bne L135E
                lda sprite_ghost_angry_row1,y
                sta ($74),y

L135E:
                dey
                bpl L133A
                ldy L0AF1
                lda L007E
                sta ghosts_table,y
                lda L007F
                sta ghosts_table+1,y

L1370:
                dec L0AF1
                dec L0AF1
                lda L0AF1
                cmp #$FE
                beq L1380
                jmp L123C

;-------------------------------------------------------------------------

L1380:
                lda L0AF2
                sta L0AF1

L1386:
                lda L0AEE
                cmp #$54
                bcs L13A8
                lda L0AF4
                cmp #3
                bcs L13A8
                rol L0AF4
                lda L0AF4
                adc #1
                sta L0AD8+4  ;pitch
                lda #7
                ldx #<L0AD8
                ldy #>L0AD8
                jsr osword

L13A8:
                rts
                .endblock

;-------------------------------------------------------------------------

update_conveyor:       .block
                dec object_var2s,x;conveyor_update_timer
                beq L13AF

L13AE:
                rts

;-------------------------------------------------------------------------

L13AF:
                ; lda conveyor_addr+1
                ; beq L13AE       ;taken if no conveyor on this level
                lda #4
                sta object_var2s,x;conveyor_update_timer
                jsr L156B
                ldy #$F

L13BD:
                lda (object_addr),y
                cmp #$66
                beq L13CB
                cmp #$08        ;left border
                beq L13CB
                dey
                bpl L13BD
                jmp draw_conveyor

;-------------------------------------------------------------------------

L13CB:
                lda object_var0s,x;conveyor_direction
                eor #1
                sta object_var0s,x;conveyor_direction
                jsr L156B

                ; fall through
                .endblock

draw_conveyor:
                ldy #$F

L13D8:
                lda sprite_conveyor,y
                sta (object_addr),y
                dey
                bpl L13D8
                rts

;-------------------------------------------------------------------------

L156B:       .block
                lda object_var0s,x;conveyor_direction
                jmp object_addr_left_or_right
                .endblock


;-------------------------------------------------------------------------

update_spider:       .block
                dec object_var2s,x;spider_update_timer
                lda object_var2s,x;spider_update_timer
                beq L13EE

L13EB:
                jmp L148F

;-------------------------------------------------------------------------

L13EE:
                ; lda spider_addr+1
                ; beq L13EB
                lda object_var1s,x;spider_speed
                sta object_var2s,x;spider_update_timer
                lda object_addr+0
                clc
                adc #$40
                sta L0072
                lda object_addr+1
                adc #1
                sta L0072+1
                lda #0
                ldy #$1F

L1409:
                sta (object_addr),y
                sta (L0072),y
                dey
                bpl L1409

L1412:
                lda object_var0s,x;spider_direction
                and #1
                jsr object_addr_up_or_down
                
                lda object_addr
                clc
                adc #$40
                sta L0072
                lda object_addr+1
                adc #1
                sta L0072+1
                ldy #$1F

L1443:
                lda (L0072),y
                cmp #$FF
                beq L1457
                cmp #$a0
                beq L1457
                lda (object_addr),y
                cmp #$FF
                beq L1457
                cmp #$a0
                beq L1457
                dey
                bpl L1443
                jmp L1462

;-------------------------------------------------------------------------

L1457:
                lda object_var0s,x;spider_direction
                eor #1
                sta object_var0s,x;spider_direction
                jmp L1412

;-------------------------------------------------------------------------

L1462:
                lda object_var0s,x;L0084
                eor #2
                sta object_var0s,x;L0084
                and #2
                beq L147E
                ldy #$1F

L146C:
                lda sprite_spider_0_row0,y
                sta (object_addr),y
                lda sprite_spider_0_row1,y
                sta (L0072),y
                dey
                bpl L146C
                rts

;-------------------------------------------------------------------------

L147E:
                ldy #$1F

L1480:
                lda sprite_spider_1_row0,y
                sta (object_addr),y
                lda sprite_spider_1_row1,y
                sta (L0072),y
                dey
                bpl L1480

L148F:
                rts
                .endblock

;-------------------------------------------------------------------------

object_addr_left_or_right:
                cmp #0
                beq object_addr_right
                ; fall through
object_addr_left: 
                sec
                lda object_addr+0
                sbc #8
                sta object_addr+0
                bcs +
                dec object_addr+1
+
                rts

object_addr_right:
                clc
                lda object_addr+0
                adc #8
                sta object_addr+0
                bcc +
                inc object_addr+1
+
                rts

object_addr_up_or_down:
                cmp #0
                beq object_addr_down
                ; fall through
object_addr_up:
                sec
                lda object_addr+0
                sbc #$40
                sta object_addr+0
                lda object_addr+1
                sbc #$01
                sta object_addr+1
                rts

object_addr_down:
                clc
                lda object_addr+0
                adc #$40
                sta object_addr+0
                lda object_addr+1
                adc #$01
                sta object_addr+1
                rts
                
;-------------------------------------------------------------------------

L1490:
                lda player_addr
                clc
                adc #$80
                sta L0076
                lda player_addr+1
                adc #2
                sta L0077
                ldy #0
                lda (L0076),y
                cmp #$A
                beq L14AD
                ldy #8
                lda (L0076),y
                cmp #$A
                bne L14CA

L14AD:
                lda #6
                sta player_jump_state
                lda #1
                sta L0AC8+4  ;pitch
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword
                lda #2
                sta L0AC8+4  ;pitch
                ldx #3
                jsr add_X_to_score

L14CA:
                ldy #0
                lda (L0076),y
                cmp #$FF
                beq L14FA
                ldy #8
                lda (L0076),y
                cmp #$FF
                beq L14FA
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                jsr L166B
                inc L0AFC
                lda L0AFC
                cmp #4
                bne L14F7
                jmp L16B4

;-------------------------------------------------------------------------

L14F7:
                jmp L0F89

;-------------------------------------------------------------------------

L14FA:
                lda player_jump_state
                bne L1519    ; taken if already jumping
                lda #$81        ; INKEY
                ldx #$B6        ; RETURN
                ldy #$FF
                jsr osbyte
                tya
                beq L1519    ; taken if not pressed
                lda #4
                sta player_jump_state
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword

L1519:
                lda #0
                sta L0AFC
                jmp L0EDA

;-------------------------------------------------------------------------

L1521:
                lda player_jump_state
                bne L1529
                jmp L0ED7

;-------------------------------------------------------------------------

L1529:
                lda player_anim_frame
                eor #1
                sta player_anim_frame
                lda player_anim_frame
                beq L1539
                jmp L1158

;-------------------------------------------------------------------------

L1539:
                lda player_jump_state
                cmp #3
                bcc L154D    ; taken if 0/1/2
; player_jump_state>=3 - move player up 1 row
                lda player_addr
                sec
                sbc #$40
                sta player_addr
                lda player_addr+1
                sbc #1
                sta player_addr+1

L154D:
                lda player_jump_state
                cmp #1
                beq L1558
                cmp #2
                bne L1565
;player_jump_state<3 - move player down 1 row

L1558:
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1

L1565:
                dec player_jump_state
                jmp L0F51

;-------------------------------------------------------------------------

L158E:
                lda #$FF
                sta level_finished
                lda player_addr
                clc
                adc #$40
                sta L0074
                lda player_addr+1
                adc #1
                sta L0075
                ldy #$F

L15A2:
                lda sprite_pl_facing,y
                sta (player_addr),y
                lda sprite_pl_facing+$10,y
                sta (L0074),y
                dey
                bpl L15A2
                lda bonus_chars+1
                sec
                sbc #230
                beq L15BD
                tax
                jsr add_X_to_score

L15BD:
                lda bonus_chars
                sec
                sbc #230
                tay
                beq L15DD
                lda #0
                sta L0E1E

L15CB:
                lda L0E1E
                clc
                adc #$A
                sta L0E1E
                dey
                bne L15CB
                ldx L0E1E
                jsr add_X_to_score

L15DD:
                pla
                pla
                rts

;-------------------------------------------------------------------------

update_bonus:   .block
                dec bonus_chars+1
                lda bonus_chars+1
                cmp #229
                bne L15FE
                lda #239
                sta bonus_chars+1
                dec bonus_chars
                lda bonus_chars
                cmp #229
                bne L15FE
                pla
                pla
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L15FE:
                ldy #1
                lda bonus_chars
                cmp #230
                bne L1617
                lda #$95
                sta L0AD0+4  ;pitch
                lda #7
                ldx #<L0AD0
                ldy #>L0AD0
                jsr osword
                ldy #1

L1617:
                lda #31
                jsr oswrch
                tya
                clc
                adc #18
                jsr oswrch
                lda #1
                jsr oswrch
                lda bonus_chars,y
                jsr oswrch
                dey
                bpl L1617
                rts
                .endblock

;-------------------------------------------------------------------------

add_X_to_score: .block
                ldy #4

L1636:
                lda score_chars,y
                clc
                adc #1
                sta score_chars,y
                cmp #240
                bne L164C
                lda #230
                sta score_chars,y
                dey
                jmp L1636

;-------------------------------------------------------------------------

L164C:
                dex
                bne add_X_to_score
                ldy #4

L1651:
                lda #$1F
                jsr oswrch
                tya
                jsr oswrch
                lda #1
                jsr oswrch
                lda score_chars,y
                jsr oswrch
                dey
                bpl L1651
                rts
                .endblock

;-------------------------------------------------------------------------

L166B:       .block
                ldx #5

L166D:
                ldy #4

L166F:
                lda score_chars,y
                sec
                sbc #1
                sta score_chars,y
                cmp #229
                bne L1695
                lda #239
                sta score_chars,y
                dey
                bpl L166F
                ldy #4
                lda #230

L168A:
                sta score_chars,y
                dey
                bpl L168A
                jmp L1698

;-------------------------------------------------------------------------

L1695:
                dex
                bne L166D

L1698:
                ldy #4

L169A:
                lda #$1F
                jsr oswrch
                tya
                jsr oswrch
                lda #1
                jsr oswrch
                lda score_chars,y
                jsr oswrch
                dey
                bpl L169A
                rts
                .endblock

;-------------------------------------------------------------------------

L16B4:
                lda #150
                sta L0AD0+4  ;pitch
                lda player_addr
                sec
                sbc #$40
                sta player_addr
                lda player_addr+1
                sbc #1
                sta player_addr+1

L16C6:
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                dec L0AD0+4  ;pitch
                lda #7
                ldx #<L0AD0
                ldy #>L0AD0
                jsr osword
                jsr L166B
                ldy #$F

L16E4:
                lda L0DDE,y  ; copy of what was under player, row 0?
                sta (player_addr),y
                lda L0DDE+16,y  ; copy of what was under player, row 1?
                sta (L0072),y
                dey
                bpl L16E4
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                bmi draw_pl_splat
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L170F:
                lda (player_addr),y
                sta L0DDE,y  ; copy of what was under player, row 0?
                lda (L0072),y
                sta L0DDE+16,y  ; copy of what was under player, row 1?
                dey
                bpl L170F
                lda L0DDE+16    ; copy of what was under player, row 1?
                cmp #$FF
                beq draw_pl_splat
                lda L0DDE+16+8  ; copy of what was under player, row 1?
                cmp #$FF
                beq draw_pl_splat
                lda L0078
                clc
                adc #$10
                sta L0074
                lda L0079
                adc #0
                sta L0075
                ldy #$F

L173B:
                lda (L0078),y
                sta (player_addr),y
                lda (L0074),y
                sta (L0072),y
                dey
                bpl L173B
                ldx #70

L174A:
                ldy #0

L174C:
                dey
                bne L174C
                dex
                bne L174A
                jmp L16C6

;-------------------------------------------------------------------------

draw_pl_splat:
                ldy #$F

L1757:
                lda sprite_pl_splat,y
                sta (player_addr),y
                dey
                bpl L1757
                lda #0
                sta L0AD0+4  ;pitch
                pla
                pla
                rts

;-------------------------------------------------------------------------

kill_player_and_drop_caller:
                pla
                pla
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L177A:
                lda L0DDE,y  ; copy of what was under player, row 0?
                sta (player_addr),y
                lda sprite_pl_splat,y
                sta (L0072),y
                dey
                bpl L177A
                rts

;-------------------------------------------------------------------------

top_right_cell=$5800+39*8
                
entry_slide_off:
                lda #<top_right_cell
                sta player_addr
                lda #>top_right_cell
                sta player_addr+1
                lda #1
                sta L0072

slide_off_loop:
                lda #19
                jsr osbyte

                lda #13
                sta $fe00
                lda L0072
                sta $fe01
                
                lda player_addr
                clc
                adc #8
                sta player_addr
                bcc +
                inc player_addr+1
+
                lda player_addr
                pha
                lda player_addr+1
                pha
; clear portion of screen just scrolled off
                ldx #32

fill_rows_loop:
                ldy #7
                lda #0

fill_row_loop:
                sta (player_addr),y
                dey
                bpl fill_row_loop
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                dex
                bne fill_rows_loop
                pla
                sta player_addr+1
                pla
                sta player_addr
                inc L0072
                lda L0072
                cmp #41
                bne slide_off_loop
                rts

;-------------------------------------------------------------------------
                .if editor
;-------------------------------------------------------------------------

ed_keys=[key_z,key_x,key_slash,key_colon,key_return,key_delete,key_tab,key_r,key_s,key_escape,key_left,key_right,key_up,key_down,key_c]

ed_key_index: .function k
                .for _i:=0,_i<len(ed_keys),_i+=1
                .breakif ed_keys[_i]==k
                .endfor
                .cerror _i==len(ed_keys),'key not found'
                .endfunction _i

; These values are set by RORs, so they can't be rearranged without
; rejigging the routine that sets them.
ed_key_flag_newly_down=$80
ed_key_flag_down=$40
ed_key_flag_rept_4=$20
ed_key_flag_rept_8=$10
                
                .section ed_zp
ed_read_addr: .fill 2
ed_level_addr: .fill 2
ed_write_addr: .fill 2
ed_print_addr: .fill 2
ed_brk_addr: .fill 2
ed_box_mode: .fill 1            ;PLOT mode
ed_box_x0: .fill 2
ed_box_y0: .fill 2
ed_box_x1: .fill 2
ed_box_y1: .fill 2
ed_cx: .fill 1
ed_cy: .fill 1
ed_new_otype: .fill 1
ed_cur_ltype: .fill 1
ed_cur_otype: .fill 1
ed_cur_ovalue: .fill 1
                .endsection
                
ed_levels_header_magic:
                .dword levels_header_magic

ed_old_language_rom:
                .byte 0

ed_post_brk_loop:
                .cerror (*&$ff)==$ff,'oh no'
                .word 0
ed_key_counters:
                .fill len(ed_keys),0
ed_key_flags:
                .fill len(ed_keys),0
ed_any_keys_pressed:
                .byte 0

ed_new_ovalues:
                .fill len(otypes),0

;-------------------------------------------------------------------------

ed_entry:
                jsr ed_one_time_init
                jmp ed_main_loop

ed_main_loop: .proc
                ldx #$ff
                txs

                lda #$7e        ;acknowledge Escape (D.2-37)
                jsr osbyte

                lda #$e5        ;escape key status (D.2-75)
                ldx #1          ;make Escape generate ASCII
                ldy #0          ;write
                jsr osbyte
                
                lda #<ed_main_loop
                sta ed_post_brk_loop+0
                lda #>ed_main_loop
                sta ed_post_brk_loop+1
                
                jmp ed_main_menu

                jmp ed_shutdown
                
                .endproc

;-------------------------------------------------------------------------

ed_shutdown: .proc
                lda #$8e        ;enter language ROM (D.2-44)
                ldx ed_old_language_rom
                jmp osbyte
                .endproc
                
;-------------------------------------------------------------------------

ed_main_menu: .proc
                jsr ed_print

                .text 22,7
                .text 129,157,131,141,10,13,129,157,131,141
                .text 31,12,0,"GHOULS: ARCHITECT"
                .text 31,12,1,"GHOULS: ARCHITECT"
                .text 31,0,3
                .byte 0

                lda ed_brk_addr+0
                ora ed_brk_addr+1
                beq brk_checked

                jsr ed_print
                .text 129,'Last error:',135
                .byte 0
                
                jsr ed_print_brk_message
                jsr osnewl
                jsr osnewl
brk_checked:
                
                ldy #0
levels_loop:
                tya
                pha

                jsr ed_prepare_for_level_access

                clc
                tya
                adc #'1'
                sta level_number_insert_1
                sta level_number_insert_2

                jsr ed_print
                .byte 133
level_number_insert_1:
                .text 'X'
                .text ':',131,'Edit level '
level_number_insert_2:
                .text 'X'
                .text ' -',134
                .byte 0

                ldy #LevelData.name
print_name_loop:
                lda (ed_level_addr),y
                bmi printed_name
                cmp #32
                bcc printed_name
                jsr oswrch
                iny
                cpy #LevelData.name+17
                bne print_name_loop
printed_name:

                jsr osnewl

                pla
                tay
                iny
                cpy #4
                bne levels_loop

                jsr ed_print

                .text 133,'N:',131,'Set level name',10,13
                .text 133,'R:',131,'Reset level',10,13
                .text 133,'L:',131,'Load levels',10,13
                .text 133,'S:',131,'Save levels',10,13
                .text 133,'*:',131,'* prompt',10,13
                .byte 0

input_loop:
                lda #15         ;flush buffer (D.2-24)
                ldx #1
                jsr osbyte
                
                jsr osrdch

                cmp #'a'
                bcc not_lower
                cmp #'z'+1
                bcs not_lower
                and #$df
not_lower:
                cmp #'L'
                beq load_levels

                cmp #'S'
                beq save_levels

                cmp #'N'
                beq name_levels

                cmp #'R'
                beq reset_level

                cmp #'*'
                beq ed_oscli_prompt

                jsr is_ascii_level_number
                bcs edit_level

                jmp input_loop

; escaped:
;                 .text 0,17,'Escape',0

select_level:
                jsr ed_print
                .text 131,'Select level (1-4):',135
                .byte 0
select_level_loop:
                jsr osrdch
                cmp #27
                beq ed_main_menu
                jsr is_ascii_level_number
                bcc select_level_loop
                jsr oswrch
                pha
                jsr osnewl
                pla
                sec
                sbc #'1'
                jsr ed_prepare_for_level_access
                rts

reset_level: .proc
                jsr select_level

                ; Reset map data
                ldy #level_height-1
y_loop:
                ldx #level_width-1
x_loop:
                lda #0
                jsr ed_write_level
                dex
                bpl x_loop
                dey
                bpl y_loop

                ; Put blocks on the bottom row
                ldx #level_width-1
                ldy #level_height-1
                lda #type_block.index
-
                jsr ed_write_level
                dex
                bpl -

                ; Clear header
                ldy #0
                ldx #LevelData.map
                lda #0
-
                sta (ed_level_addr),y
                iny
                dex
                bne -

                ; Reset name
                ldy #LevelData.name
                ldx #17
                lda #13
-
                sta (ed_level_addr),y
                iny
                dex
                bne -

                ; Other stuff
                lda #1
                ldy #LevelData.pl_start_x
                sta (ed_level_addr),y

                lda #23
                ldy #LevelData.pl_start_y
                sta (ed_level_addr),y

                lda #7
                ldy #LevelData.colour3
                sta (ed_level_addr),y

                jmp ed_main_menu

                .endproc
                
name_levels:
                jsr select_level
                
                jsr ed_print
                .text 131,'Enter name:',132,157,135
                .fill 16+2,' '
                .text 156
                .fill 16+3,8
                .byte 0

                ldy #LevelData.name
                ldx #17
                lda #13
-
                sta (ed_level_addr),y
                iny
                dex
                bne -
                
                clc
                lda ed_level_addr+0
                adc #LevelData.name
                sta name_level_block+0
                lda ed_level_addr+1
                adc #0
                sta name_level_block+1

                ldx #<name_level_block
                ldy #>name_level_block
                lda #0
                jsr osword
                jmp ed_main_menu

name_level_block:
                .word 0
                .byte 16        ;max length (excl CR)
                .byte 32        ;min char
                .byte 126       ;max char
                
edit_level:
                sec
                sbc #'1'
                jsr ed_prepare_for_level_access
                jmp ed_editor

is_ascii_level_number:
                cmp #'1'
                bcc not_level_number
                cmp #'4'+1
                bcs not_level_number
                sec
                rts
not_level_number:
                clc
                rts
                
load_levels:
                jsr ed_print
                .text 131,'Load levels',10,13
                .byte 0

                jsr enter_file_name

                jsr init_file_load_save_block

                ; load file to address given in control block
                sta file_load_save_block.exec+0

                lda #$ff        ;load file
file_load_save_osfile:
                ldx #<file_load_save_block
                ldy #>file_load_save_block
                jsr osfile
                jmp ed_main_loop
                
save_levels:
                jsr ed_print
                .text 131,'Save levels',10,13
                .byte 0

                jsr enter_file_name

                jsr init_file_load_save_block

                lda #$00        ;save file
                jmp file_load_save_osfile

init_file_load_save_block:
                ; I don't trust the OSFILE block not to get modified.
                lda file_name_block+0
                sta file_load_save_block.name+0
                lda file_name_block+1
                sta file_load_save_block.name+1
                
                lda #<levels_org
                sta file_load_save_block.load+0
                sta file_load_save_block.exec+0
                sta file_load_save_block.start+0
                
                lda #>levels_org
                sta file_load_save_block.load+1
                sta file_load_save_block.exec+1
                sta file_load_save_block.start+1

_levels_end=levels_org+level_data_pages*256
                lda #<_levels_end
                sta file_load_save_block.end+0
                lda #>_levels_end
                sta file_load_save_block.end+1
                
                lda #$ff
                sta file_load_save_block.load+2
                sta file_load_save_block.exec+2
                sta file_load_save_block.start+2
                sta file_load_save_block.end+2
                sta file_load_save_block.load+3
                sta file_load_save_block.exec+3
                sta file_load_save_block.start+3
                sta file_load_save_block.end+3

                rts

enter_file_name:
                jsr ed_print
                .text 131,'Enter file name:',135
                .byte 0

                jsr ed_enable_escape

                ldx #<file_name_block
                ldy #>file_name_block
                lda #0
                jsr osword
                bcs ed_main_loop
                rts

file_name_block:
                .word $7b00     ;definitely safe
                .byte 255       ;max length
                .byte 32        ;min char
                .byte 126       ;max char

file_load_save_block: .block
name:
                .word $7b00
load:
                .dword 0
exec:
                .dword 0
start:
                .dword 0
end:
                .dword 0
                .endblock

                .endproc

;-------------------------------------------------------------------------

ed_enable_escape:
                lda #$e5        ;escape status (D.2-75)
                ldx #0          ;enable escape generation
                ldy #0          ;write
                jmp osbyte
                
;-------------------------------------------------------------------------

ed_oscli_prompt: .proc
                ldx #$ff
                txs

                lda ed_brk_addr+0
                ora ed_brk_addr+1
                beq brk_checked

                jsr ed_print_brk_message
                jsr osnewl
brk_checked:
                jsr ed_enable_escape
                
                lda #<ed_oscli_prompt
                sta ed_post_brk_loop+0
                lda #>ed_oscli_prompt
                sta ed_post_brk_loop+1
                
                lda #'*'
                jsr oswrch

                ldx #<block
                ldy #>block
                lda #0          ;read line from input
                jsr osword
                bcs ed_main_loop

                ldx block+0
                ldy block+1
                jsr oscli

                jmp ed_oscli_prompt

block:
                .word $7b00     ;definitely safe
                .byte 255       ;max length
                .byte 32        ;min char
                .byte 126       ;max char
                .endproc

;-------------------------------------------------------------------------

ed_editor: .proc
                ldx #len(ed_keys)-1
                lda #0
-
                sta ed_key_counters,x
                dex
                bpl -

                lda #$ff
                sta ed_cur_ltype

                jsr ed_coff

                jsr redraw
                
                lda #0
                sta ed_cx
                sta ed_cy

                jsr draw_new_otype
edit_loop:
                lda #19
                jsr osbyte
                
                jsr ed_con
                
                ldx ed_cx
                ldy ed_cy
                jsr ed_gotoxy

                jsr ed_scan_keys

                lda ed_any_keys_pressed
                beq update_stuff

                ldy #len(key_actions)-1
keys_loop:
                ldx key_indexes,y
                lda ed_key_flags,x
                and key_masks,y
                beq next_key

                lda key_routines_lo,y
                sta jsr_key_routine+1
                lda key_routines_hi,y
                sta jsr_key_routine+2
                tya
                pha
jsr_key_routine: jsr $ffff
                pla
                tay
next_key:
                dey
                bpl keys_loop
                jmp edit_loop

update_stuff: .proc
                ldx ed_cx
                ldy ed_cy
                jsr ed_read_level
                cmp ed_cur_ltype
                beq edit_loop

                sta ed_cur_ltype

                ldx #5
                ldy #29
                lda ed_cur_otype
                jsr ed_erase_otype

                lda ed_cur_ltype
                jsr ed_find_otype

                stx ed_cur_otype
                sta ed_cur_ovalue
                
                ldx #5
                ldy #29
                lda ed_cur_otype
                jsr ed_draw_otype

                ldx #14
                ldy #29
                jsr ed_gotoxy

                ldx ed_cur_otype
                jsr get_num_ovalues
                bne +
                jsr no_ovalue
                jmp edit_loop
+
                lda ed_cur_ovalue
                jsr ed_print_dec
                jmp edit_loop
                .endproc


; entry conditions for routine:
;
; X = index of key in ed_key_flags
;
key_action: .function k,mask,routine
                .endfunction {.key_index:ed_key_index(k),.mask:mask,.routine:routine}

_:=[]
_..=[key_action(key_z,ed_key_flag_rept_4,move_left)]
_..=[key_action(key_x,ed_key_flag_rept_4,move_right)]
_..=[key_action(key_slash,ed_key_flag_rept_4,move_down)]
_..=[key_action(key_colon,ed_key_flag_rept_4,move_up)]
_..=[key_action(key_escape,ed_key_flag_newly_down,ed_main_loop)]
_..=[key_action(key_r,ed_key_flag_newly_down,redraw)]
_..=[key_action(key_s,ed_key_flag_newly_down,set_start_pos)]
_..=[key_action(key_left,ed_key_flag_rept_8,prev_otype)]
_..=[key_action(key_right,ed_key_flag_rept_8,next_otype)]
_..=[key_action(key_up,ed_key_flag_rept_4,next_ovalue)]
_..=[key_action(key_down,ed_key_flag_rept_4,prev_ovalue)]
_..=[key_action(key_return,ed_key_flag_down,add_object)]
_..=[key_action(key_delete,ed_key_flag_down,erase_object)]
_..=[key_action(key_tab,ed_key_flag_newly_down,test_level)]
_..=[key_action(key_c,ed_key_flag_newly_down,next_colour)]
key_actions=_

key_indexes: .byte key_actions.key_index
key_masks: .byte key_actions.mask
key_routines_lo: .byte <key_actions.routine
key_routines_hi: .byte >key_actions.routine

next_colour:
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                clc
                adc #1
                sta (ed_level_addr),y
                jmp redraw

test_level:
                jsr ed_coff
                jsr ed_test
                jmp ed_editor
                
erase_object:
                lda #0
                jmp add_object.place_ltype
                
add_object: .proc
                ldy ed_new_otype
                lda otypes_ed_flags,y
                and #ed_flags_repeat
                bne add

                lda ed_key_flags,x
                and #ed_key_flag_newly_down
                beq done
                
add:
                ldx ed_new_otype
                lda ed_new_ovalues,y
                jsr ed_pack_ltype
                
place_ltype:
                ldx ed_cx
                ldy ed_cy
                jsr ed_place_ltype

done:
                rts
                .endproc
                
get_num_ovalues:
                sec
                lda otypes_ltype_end,x
                sbc otypes_ltype_begin,x
                ; C=1
                sbc #1
                rts
                
next_ovalue: .proc
                jsr ed_coff
                ldx ed_new_otype
                jsr get_num_ovalues
                beq done
                cmp ed_new_ovalues,x
                beq wrap
                inc ed_new_ovalues,x
print:
                jsr print_new_ovalue
done:
                rts
wrap:
                lda #0
                sta ed_new_ovalues,x
                beq print
                .endproc

prev_ovalue: .proc
                jsr ed_coff
                ldx ed_new_otype
                jsr get_num_ovalues
                beq done
                dec ed_new_ovalues,x
                bpl print
                sta ed_new_ovalues,x
print:
                jsr print_new_ovalue
done:
                rts
                .endproc

prev_otype:
                jsr ed_coff
                jsr erase_new_otype
                ldx ed_new_otype
                dex
                bpl +
                ldx #len(otypes)-1
+
                stx ed_new_otype
                jsr draw_new_otype
                rts
                
next_otype:
                jsr ed_coff
                jsr erase_new_otype
                ldx ed_new_otype
                inx
                cpx #len(otypes)
                bcc +
                ldx #0
+
                stx ed_new_otype
                jsr draw_new_otype
                rts

erase_new_otype:
                ldx #5
                ldy #27
                lda ed_new_otype
                jmp ed_erase_otype
                
draw_new_otype:
                ldx #5
                ldy #27
                lda ed_new_otype
                jsr ed_draw_otype

print_new_ovalue:
                ldx #14
                ldy #27
                jsr ed_gotoxy

                ldx ed_new_otype
                jsr get_num_ovalues
                beq no_ovalue
                lda ed_new_ovalues,x
                jmp ed_print_dec

no_ovalue:
                jsr ed_print
                .text '--'
                .byte 0
                rts
                
set_start_pos:
                lda ed_cx
                ldy #LevelData.pl_start_x
                sta (ed_level_addr),y

                lda ed_cy
                ldy #LevelData.pl_start_y
                sta (ed_level_addr),y

                ; fall through

redraw:
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                sta colour3_physical_colour
                
                jsr ed_print
                .text 22,5
                .byte 19,3
colour3_physical_colour:
                .byte 7
                .byte 0,0,0

                .byte 17,2
                .text 31,0,27,'NEW:'
                .text 31,8,27,'CVAL:'
                .text 31,0,29,'CUR:'
                .text 31,8,29,'CVAL:'
                
                .byte 0

                jsr ed_draw_level

                ldy #1
                jsr ed_gcol0

                lda #0
                sta ed_box_x0
                sta ed_box_y0
                lda #19
                sta ed_box_x1
                lda #25
                sta ed_box_y1
                lda #5
                jsr ed_box

                rts
                
move_left:
                ldx ed_cx
                beq +
                dex
+
                stx ed_cx
                rts

move_right:
                ldx ed_cx
                cpx #level_width-1
                bcs +
                inx
+
                stx ed_cx
                rts

move_up:
                ldx ed_cy
                beq +
                dex
+
                stx ed_cy
                rts

move_down:
                ldx ed_cy
                cpx #level_height-1
                bcs +
                inx
+
                stx ed_cy
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Split ltype into otype and create parameter.
; 
; Entry: A=ltype
; Exit: X=otype
;       A=create parameter
; Preserves: Y
ed_find_otype: .proc
                ldx #len(otypes)-1
loop:
                cmp otypes_ltype_end,x
                bcs next
                cmp otypes_ltype_begin,x
                bcc next
                
                sbc otypes_ltype_begin,x
                rts

next:
                dex
                bpl loop

                ; Assume it was the blank entry...
                inx             ;X=0
                txa             ;A=0
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Pack otype and create parameter into ltype.
; 
; Entry: X=otype
;        A=create parameter
; Exit: A=ltype
ed_pack_ltype: .proc
                clc
                adc otypes_ltype_begin,x

                ; Clamp. Be vaguely resilient.
                cmp otypes_ltype_begin,x
                bcc min

                cmp otypes_ltype_end,x
                bcc done

                lda otypes_ltype_end,x
done:
                rts

min:
                lda otypes_ltype_begin,x
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Get player start pos.
;
; Entry: ed_level_addr = address of level
; Exit: X = player start X (0-19)
;       Y = player start Y (0-25)
ed_get_pl_start: .proc
                ldy #LevelData.pl_start_x
                lda (ed_level_addr),y
                tax

                ldy #LevelData.pl_start_y
                lda (ed_level_addr),y
                tay
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Get number of possible create parameters for the given otype. Valid
; create parameters start at 0.
; 
; Entry: A = otype
; Return: A = number of valid create parameters
ed_get_num_otype_create_parameters: .proc
                tax
                cpx #len(otypes)
                bcs none

                sec
                lda otypes_ltype_end,x
                sbc otypes_ltype_begin,x
                rts

none:
                lda #0
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Test current level.
;
; Entry: ed_level_addr = address of level
ed_test: .proc
                jsr reset_envelopes
                
                lda ed_level_addr+0
                sta level_draw_ptr+0
                lda ed_level_addr+1
                sta level_draw_ptr+1
                
                lda #12
                jsr oswrch

                ; Set up player start pos.
                jsr ed_get_pl_start
                ; Adjust for editor vs game positioning.
                iny
                iny
                iny
                iny
                jsr ed_get_screen_write_addr
                lda ed_write_addr+0
                sta player_addr+0
                lda ed_write_addr+1
                sta player_addr+1

                ; ; Default player start pos
                ; lda #$00
                ; sta player_addr+0
                ; lda #$7A
                ; sta player_addr+1

                ldx #0          ;no ghosts
                jsr entry_init_level

                ; Reset ghosts table
                ldx #7
-
                lda #0
                sta ghosts_table,x
                dex
                bpl -
                
                ; ; ???
                ; lda #0
                ; sta L0084

                ; Whatever was behind player previously
                ldy #31
-
                lda (player_addr),y
                sta L0DDE,y
                dey
                bpl -

                ; Initial bonus and score
                ldx #4
-
                lda initial_score,x
                sta score_chars,x
                dex
                bpl -

                lda initial_bonus+0
                sta bonus_chars+0
                lda initial_bonus+1
                sta bonus_chars+1

                ; Copy level name

                lda #<1279
                sta level_name_x+0
                lda #>1279
                sta level_name_x+1
                
                ldy #LevelData.name
                ldx #0
name_len_loop:
                lda (ed_level_addr),y
                sta level_name,x
                cmp #13
                beq +

                sec
                lda level_name_x+0
                sbc #64
                sta level_name_x+0
                bcs +
                dec level_name_x+1
+
                iny
                inx
                cpx #17
                bne name_len_loop

                jsr ed_print

                ; GCOL 0,1
                .byte 18,0,1

                ; VDU 5
                .byte 5

                ; MOVE ???,1023-30*32
                .byte 25,4
level_name_x:
                .word 0
                .word 28

                ; Space for level name. Any embedded CRs are copied
                ; too... VDU 5, so whatever.
level_name:
                .fill 17,'x'

                ; VDU 4
                .byte 4

                ; MOVE 0,60
                .byte 25,4
                .word 0,60

                ; DRAW 0,952
                .byte 25,5
                .word 0,952

                ; MOVE 1279,60
                .byte 25,4
                .word 1279,60

                ; DRAW 1279,952
                .byte 25,5
                .word 1279,952

                ; MOVE 1080,800
                .byte 25,4
                .word 1080,800
                
                ; DRAW 1080,860
                .byte 25,5
                .word 1080,860
                
                ; GCOL 0,2
                .byte 18,0,2
                
                ; MOVE 0,952
                .byte 25,4
                .word 0,952
                
                ; PLOT 21,1279,952
                .byte 25,21
                .word 1279,952
                
                ; MOVE 1092,864
                .byte 25,4
                .word 1092,864
                
                ; DRAW 1270,864
                .byte 25,5
                .word 1270,864

                ; COLOUR 1
                .byte 17,1

                ; PRINT TAB(14,1)
                .byte 31,14,1

                ; "BONUS"
                .byte 240,241,242

                ; COLOUR 2
                .byte 17,2

                ; PRINT TAB(0,1)
                .byte 31,0,1

                ; Default score
initial_score:
                .byte 230,230,230,230,230

                ; PRINT TAB(18,1)
                .byte 31,18,1

                ; Default bonus chars
initial_bonus:
                .byte 235,230

                .byte 0

                ; VDU 4 switches the cursor back on.
                jsr ed_coff
                
                jsr entry_game_2

                ; Flush all buffers.
                lda #15
                ldx #0
                jsr osbyte
                rts
                
entry_game_2:
                jsr entry_game
                rts

                .endproc
                
;-------------------------------------------------------------------------
;
; Draw current level.
;
; Entry: ed_level_addr = current level
ed_draw_level: .proc

                lda #19
                jsr oswrch
                lda #3
                jsr oswrch
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                jsr oswrch
                lda #0
                jsr oswrch
                jsr oswrch
                jsr oswrch

                lda #0
                sta yc
y_loop:
                lda #0
                sta xc
x_loop:
                ldx xc
                ldy yc
                jsr ed_read_level
                
                ldx xc
                ldy yc
                jsr ed_draw_ltype

                inc xc
                lda xc
                cmp #level_width
                bne x_loop

                inc yc
                lda yc
                cmp #level_height
                bne y_loop

                ; Ick. Special case :(
                jsr ed_get_pl_start
                jsr ed_get_screen_write_addr
                
                ldy #15
-
                lda sprite_pl_facing,y
                sta (ed_write_addr),y
                dey
                bpl -
                jsr ed_next_write_addr_screen_row
                ldy #15
-
                lda sprite_pl_facing+16,y
                sta (ed_write_addr),y
                dey
                bpl -
                rts

xc: .byte 0
yc: .byte 0
                .endproc

;-------------------------------------------------------------------------

ed_place_ltype: .proc
                pha
                jsr ed_read_level
                jsr ed_erase_ltype
                pla

                pha
                jsr ed_write_level
                pla
                
                ; Assume the old item was 2x2 and the new is 1x1.
                jsr ed_draw_ltype

                inx
                jsr ed_read_level
                bcs +           ;taken if (X+1,Y+0) is out of bounds
                jsr ed_draw_ltype
+
                dex

                iny
                jsr ed_read_level
                bcs +           ;taken if (X+0,Y+1) is out of bounds
                jsr ed_draw_ltype

                ; since (X+1,Y+0) wasn't out of bounds, and (X+0,Y+1)
                ; wasn't out of bounds, (X+1,Y+1) isn't out of bounds
                ; either.
                inx
                jsr ed_read_level
                jsr ed_draw_ltype
+
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Draw an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_draw_ltype: .proc
                clc             ;drawing
                jmp ed_draw_or_erase_ltype
                .endproc

;-------------------------------------------------------------------------
;
; Erase an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_erase_ltype: .proc
                sec             ;erasing
                jmp ed_draw_or_erase_ltype
                .endproc

;-------------------------------------------------------------------------
;
; Draw an object, given the otype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_draw_otype: .proc
                clc             ;drawing
                jmp ed_draw_or_erase_otype
                .endproc

;-------------------------------------------------------------------------
;
; Erase an object, given the otype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_erase_otype: .proc
                sec             ;erasing
                jmp ed_draw_or_erase_otype
                .endproc
                
;-------------------------------------------------------------------------
;
; Draw or erase an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
;        C = 0 to draw, 1 to erase
; Preserves: X/Y
ed_draw_or_erase_ltype: .proc
                ror ed_draw_or_erase_otype.erasing       ;bit 7 set if erasing
                stx ed_draw_or_erase_otype.xc
                sty ed_draw_or_erase_otype.yc

                jsr ed_find_otype
                jmp ed_draw_or_erase_otype.common
                .endproc

;-------------------------------------------------------------------------
;
; Draw or erase an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
;        C = 0 to draw, 1 to erase
; Preserves: X/Y
ed_draw_or_erase_otype: .proc
                ror erasing
                stx xc
                sty yc
                
                tax             ;X=otype
common:
                lda otypes_otype_flags,x
                sta otype_flags
                lda otypes_ed_flags,x
                sta ed_flags
                lda otypes_sprite_data_lo,x
                sta ed_read_addr+0
                lda otypes_sprite_data_hi,x
                sta ed_read_addr+1

                jsr row

                lda otype_flags
                and #otype_flags_height2
                beq done        ;taken if height=1

                ; lda yc
                ; cmp #level_height-1
                ; beq done

                inc yc
                jsr row
                dec yc

done:
                ldx xc
                ldy yc
                rts
                
row:
                ldx xc
                ldy yc
                jsr ed_get_screen_write_addr
                
                jsr do_item_part

                lda otype_flags
                and #otype_flags_width2
                beq row_done    ;taken if width=1

                ; lda xc
                ; cmp #level_width-1
                ; beq row_done

do_item_part:
                ldy #15
                lda #0
                bit erasing
                bmi erase_part_loop ;taken if erasing

                ; The blank item doesn't overwrite. 
                lda ed_read_addr+0
                ora ed_read_addr+1
                beq next_column
                
                ldx #0          ;Unmasked mask
                lda ed_flags
                and #ed_flags_masked
                beq +           ;taken if unmasked
                ldx #2          ;Masked mask
+
part_loop:
                lda (ed_read_addr),y
                and masks+0,x
                sta (ed_write_addr),y
                dey

                lda (ed_read_addr),y
                and masks+1,x
                sta (ed_write_addr),y
                dey

                bpl part_loop

next_part:
                lda #16
                ldx #ed_read_addr
                jsr ed_add16z

next_column:
                lda #16
                ldx #ed_write_addr
                jsr ed_add16z

row_done:
                rts
                
erase_part_loop:
                sta (ed_write_addr),y
                dey
                bpl erase_part_loop
                bmi next_part

masks:
                .byte $ff,$ff   ;unmasked
                .byte $ff,$00   ;masked

erasing:
                .byte 0
xc:
                .byte 0
yc:
                .byte 0                
otype_flags:
                .byte 0
ed_flags:
                .byte 0
                .endproc
                
;-------------------------------------------------------------------------
;
; Set ed_write_addr to the screen address for a given X/Y coordinate.
;
; Entry: X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Exit: ed_write_addr = screen address
; Preserves: X/Y
ed_get_screen_write_addr: .proc
                lda #0
                sta ed_write_addr+0

                sty ed_write_addr+1 ;*256

                tya
                lsr a               ;>*128
                ror ed_write_addr+0 ;<*128
                lsr a               ;>*64
                ror ed_write_addr+0 ;<*64 (C=0)
                
                adc ed_write_addr+1
                sta ed_write_addr+1

                txa
                asl a           ;*2 (0-38)
                asl a           ;*4 (0-76)
                asl a           ;*8 (0-152)
                asl a           ;*16 (0-304)
                bcc +
                inc ed_write_addr+1 ;definitely needed
+
                clc
                adc ed_write_addr+0
                sta ed_write_addr+0
                bcc +
                inc ed_write_addr+1
+

                ; The editor screen starts at (0,0).
                clc
                lda ed_write_addr+1
                adc #$58
                sta ed_write_addr+1
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read value from level map.
;
; Entry: ed_level_addr = address of level
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Exit: A = value read from map
; Preserves: X/Y
ed_read_level: .proc
                sty reload_y+1
                jsr ed_prepare_for_level_map_access
                lda (ed_read_addr),y
reload_y: ldy #$ff
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Write value to level map.
;
; Entry: ed_level_addr = address of level
;        A = value to write
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: A/X/Y
ed_write_level: .proc
                sty reload_y+1
                pha
                jsr ed_prepare_for_level_map_access
                pla
                sta (ed_read_addr),y ;hmm
reload_y: ldy #$ff
                rts
                .endproc

;-------------------------------------------------------------------------
; 
; Sets things up so that (ed_read_addr),Y will access the appropriate
; value in the level.
;
; Entry: ed_level_addr = address of level
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Exit: ed_read_addr = address
;       Y = offset for address
;       C = 0 if valid coordinates, 1 if invalid coordinates
; Preserves: X
ed_prepare_for_level_map_access: .proc
                cpx #level_width
                bcs done
                cpy #level_height
                bcs done

                lda #0
                sta ed_read_addr+1

                ; Y*16
                tya
                asl a           ;*2 - 0-50
                asl a           ;*4 - 0-100
                asl a           ;*8 - 0-200
                rol ed_read_addr+1
                asl a           ;*16 - 0-400
                rol ed_read_addr+1
                sta ed_read_addr+0

                ; Y*16+Y*4 = Y*20
                tya
                asl a           ;*2
                asl a           ;*4 (C=0)
                adc ed_read_addr+0
                sta ed_read_addr+0
                bcc +
                inc ed_read_addr+1
+

                clc
                lda ed_read_addr+0
                adc ed_level_addr+0
                sta ed_read_addr+0
                lda ed_read_addr+1
                adc ed_level_addr+1
                sta ed_read_addr+1

                ; This is stupid, but it's going to be too confusing
                ; to call from BASIC otherwise.
                txa
                clc
                adc #LevelData.map
                tay
done:
                rts
                .endproc


;-------------------------------------------------------------------------
;
; Set cursor on (con) or off (coff)
;
; Preserves: X
ed_coff:
                lda #10
                bne set_r10
ed_con:
                lda #0
set_r10:
                ldx #10
                stx $fe00
                sta $fe01
                rts

;-------------------------------------------------------------------------
;
; Do a PRINT TAB
;
; Entry: X = X coordinate
;        Y = Y coordinate
; Preserves: X/Y
ed_gotoxy: .proc
                lda #31
                jsr oswrch
                txa
                jsr oswrch
                tya
                jmp oswrch
                .endproc

;-------------------------------------------------------------------------
;
; Do a GCOL 0,y
;
; Entry: Y = colour
; Preserves: X/Y

ed_gcol0: .proc
                lda #18
                jsr oswrch
                lda #0
                jsr oswrch
                tya
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
;
; Draw a box surrounding the specified range of map squares.
;
; The box edges are to the top and left of the top left square, and the
; bottom and right of the bottom right square.
;
; Entry: A = plot mode for the lines, as per PLOT/VDU 25
;        ?ed_box_x0 = X coord of top left square (0-19)
;        ?ed_box_y0 = Y coord of top left square (0-25)
;        ?ed_box_x1 = X coord of bottom right square (0-19)
;        ?ed_box_y1 = Y coord of bottom right square (0-25)

ed_box: .proc
                sta ed_box_mode
                
                ; x0*64
                ldx #ed_box_x0
                ldy #6
                jsr shlzbw

                ; 1023-y0*32
                ldx #ed_box_y0
                ldy #5
                jsr shlzbw
                jsr rsub1023zw

                ; x1*64+63
                ldx #ed_box_x1
                ldy #6
                jsr shlzbw
                lda #63
                jsr ed_add16z

                ; 1023-(y1*32+31)
                ldx #ed_box_y1
                ldy #5
                jsr shlzbw
                lda #31
                jsr ed_add16z
                jsr rsub1023zw

                lda #4
                ldx #ed_box_x0
                ldy #ed_box_y0
                jsr plot

                lda ed_box_mode
                ldx #ed_box_x1
                ldy #ed_box_y0
                jsr plot

                lda ed_box_mode
                ldx #ed_box_x1
                ldy #ed_box_y1
                jsr plot
                
                lda ed_box_mode
                ldx #ed_box_x0
                ldy #ed_box_y1
                jsr plot

                lda ed_box_mode
                ldx #ed_box_x0
                ldy #ed_box_y0
                jsr plot

                rts

plot:
                pha
                lda #25
                jsr oswrch
                pla
                jsr oswrch
                lda 0,x
                jsr oswrch
                lda 1,x
                jsr oswrch
                lda 0,y         ;16 bit address ;(
                jsr oswrch
                lda 1,y         ;16 bit address ;(
                jmp oswrch
                
rsub1023zw:
                sec
                lda #<1023
                sbc 0,x
                sta 0,x
                lda #>1023
                sbc 1,x
                sta 1,x
                rts
                
shlzbw:
                lda #0
                sta 1,x
-
                asl 0,x
                rol 1,x
                dey
                bne -
                rts

                .endproc

;-------------------------------------------------------------------------
;
; Scan editor keys
;
ed_scan_keys: .proc

                lda #0
                sta ed_any_keys_pressed
                
                ldy #len(ed_keys)-1
loop:
                tya
                pha

                lda #$81
                ldx table,y
                jsr ed_osbyte_yff
                cpx #$ff        ;C=1 if pressed

                pla
                tay

                lda #0
                bcc store

                lda #$ff
                sta ed_any_keys_pressed

                ldx ed_key_counters,y
                cpx #$80        ;C=1 if bit 7 set
                inx
                txa
                bcc store
                ; keep counting in bits 0-7, but suppress further
                ; occurrences of $00 or $01
                ora #$80

store:
                sta ed_key_counters,y

                ; repeat 8
                pha
                and #7
                jsr if1

                ; repeat 4
                and #3
                jsr if1

                ; down
                pla
                cmp #1
                ror lda_key_flags+1

                ; newly down
                jsr if1

lda_key_flags: lda #$ff
                sta ed_key_flags,y

                dey
                bpl loop
                rts

if1:
                cmp #1
                beq +
                clc
+
                ror lda_key_flags+1
                rts

table:
                .for _i:=0,_i<len(ed_keys),_i+=1
                .byte inkey(ed_keys[_i])
                .endfor
                .endproc
                

;-------------------------------------------------------------------------
;
; Sets up ed_level_addr for access to a specific level.
; 
; Entry: A = level index, 0-3
; Exit: ed_level_addr set up
; Preserves: Y
; 
ed_prepare_for_level_access: .proc
                tax
                
                lda #<(levels_org+4)
                sta ed_level_addr+0
                lda #>(levels_org+4)
                sta ed_level_addr+1

loop:
                txa
                beq done

                clc
                lda ed_level_addr+0
                adc #<size(LevelData)
                sta ed_level_addr+0
                lda ed_level_addr+1
                adc #>size(LevelData)
                sta ed_level_addr+1

                dex
                jmp loop
done:
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Check if if looks like valid level data is loaded.
;
; Exit: C=1 if yes, C=0 if no
; 
ed_check_levels_header_magic: .proc
                ldx #3
loop:
                lda levels_org,x
                cmp ed_levels_header_magic,x
                bne no
                dex
                bpl loop
                rts
no:
                clc
                rts
                .endproc

;-------------------------------------------------------------------------
;
; BRK handler. Stores the BRK address in (ed_brk_addr) and jumps to
; the post-BRK routine.
; 
ed_brk_handler: .proc
                lda $fd
                sta ed_brk_addr+0
                lda $fe
                sta ed_brk_addr+1

                jmp (ed_post_brk_loop)
                .endproc

;-------------------------------------------------------------------------
;
; Print last BRK message and reset the brk message pointer.
;
; Exit: ed_brk_addr?0 = 0
;       ed_brk_addr?1 = 0
; Preserves: X
ed_print_brk_message: .proc
                ldy #1
loop:
                lda (ed_brk_addr),y
                beq done
                jsr oswrch
                iny
                bne loop
done:

                jsr ed_print
                .text 10,13,129,'(Error addr: &',0
                lda ed_brk_addr+1
                jsr ed_print_hex
                lda ed_brk_addr+0
                jsr ed_print_hex
                jsr ed_print
                .text ')',10,13,129,'(Error number: &',0
                ldy #0
                lda (ed_brk_addr),y
                jsr ed_print_hex
                jsr ed_print
                .text ')',10,13,0
                
                lda #0
                sta ed_brk_addr+0
                sta ed_brk_addr+1
                rts
                .endproc
                
;-------------------------------------------------------------------------

ed_one_time_init: .proc
                lda #$fc        ;current language ROM (D.2-83)
                jsr ed_osbyte_x00_yff
                stx ed_old_language_rom

                lda #<ed_brk_handler
                sta brkv+0
                lda #>ed_brk_handler
                sta brkv+1
                
                ldx #ed_zp_begin
                lda #0
-
                sta 0,x
                inx
                cpx #ed_zp_end
                bne -
                
                ldx #<run_gudgs
                ldy #>run_gudgs
                jsr oscli

                jsr ed_check_levels_header_magic
                bcs levels_loaded ;some left in RAM

                ldx #<load_glevels
                ldy #>load_glevels
                jsr oscli

levels_loaded:
                rts

run_gudgs:
                .text '/$.GUDGS',13

load_glevels:
                .text 'LOAD $.GLEVELS',13
                .endproc

;-------------------------------------------------------------------------
;
; Print 0-terminated string following call.
;
; 0 bytes in VDU commands are handled correctly. The terminating 0
; must stand on its own. (This does mean the string can't be
; terminated in the middle of a command sequence.)
; 
ed_print: .proc
                pla
                sta ed_print_addr+0
                pla
                sta ed_print_addr+1

loop:
                ldx #ed_print_addr
                jsr ed_incz

                lda (0,x)
                bne print

                lda #$da
                jsr ed_osbyte_x00_yff
                cpx #0
                beq done

                lda #0
print:
                jsr oswrch
                jmp loop

done:
                lda ed_print_addr+1
                pha
                lda ed_print_addr+0
                pha
                rts

                .endproc

;-------------------------------------------------------------------------
;
; Print 2-digit decimal value using OSWRCH
;
; Entry: A = value to print, 0-99 ($00-$63)
; Preserves: Y
ed_print_dec: .proc
                ldx #'0'
-
                sec
                sbc #10
                bcc +
                inx
                bne -
+
                adc #10
                pha
                txa
                jsr oswrch
                pla
                clc
                adc #'0'
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
; 
; Print hex value using OSWRCH
;
; Entry: A = value to print
; Preserves: X/Y
ed_print_hex: .proc
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr nybble
                pla
                and #$0f
nybble:
                sed
                clc
                adc #$90
                adc #$40
                cld
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
;
; Increment zero page word.
;
; Entry: X = zp address of word
; Preserves: A/X/Y/C
ed_incz: .proc
                inc 0,x
                bne +
                inc 1,x
+
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Add 320 to ed_write_addr, moving the address to the next screen row.
;
; Entry: ed_write_addr = address
; Exit: ed_write_addr = address+320
; Preserves: X/Y
ed_next_write_addr_screen_row: .proc
                clc
                lda ed_write_addr+0
                adc #$40
                sta ed_write_addr+0
                lda ed_write_addr+1
                adc #$01
                sta ed_write_addr+1
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Add an 8-bit value to a 16-bit zero page value.
;
; Entry: A = 8-bit value
;        X = address of 16-bit value
; Preserves: X/Y
ed_add16z: .proc
                clc
                adc 0,x
                sta 0,x
                bcc +
                inc 1,x
+
                rts
                .endproc

;-------------------------------------------------------------------------

ed_osbyte_x00_yff:
                ldx #$00
ed_osbyte_yff:
                ldy #$ff
                jmp osbyte
                
;-------------------------------------------------------------------------
                .endif          ;editor
;-------------------------------------------------------------------------

                .if editor
                .cerror *-gmc_start>max_gedmc_pages*256,"gedmc overflow"
                .else
                .cerror *-gmc_start>max_gmc_pages*256,"gmc overflow"
                .endif
                
