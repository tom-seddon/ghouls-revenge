                .include "gcommon.s65"

;-------------------------------------------------------------------------

                .if editor
*=$00
ed_zp_begin:
                .dsection ed_zp
                
                ; see BASIC ROM user guide and
                ; http://8bs.com/basic/memory.htm - in practice $50
                ; onwards is free
ed_basic_friendly_zp_start=$50
                .if *<ed_basic_friendly_zp_start
*=ed_basic_friendly_zp_start
                .endif
                .dsection ed_basic_friendly_zp
ed_zp_end:
                .cerror *>$70,'ed_zp overflow'
                .endif
                
;-------------------------------------------------------------------------

player_addr=$70

; screen address for writing sprite
L0072=$72

; screen address for writing sprite row 1
L0074=$74
L0075=$75
L0076=$76
L0077=$77

; data address for row 0 of player sprite
L0078=$78
L0079=$79
was_platform_addr=$7a
L007C=$7c
L007E=$7e
L007F=$7f
was_conveyor_addr=$80           ; Crap name, since it doesn't even
                                ; convey! I just noticed too late that
                                ; the objects page calls this the
                                ; moving floor
object_addr=$82
level_draw_ptr=$84
;L0084=$84
L0085=$85
level_draw_screen_addr=$86
                
;-------------------------------------------------------------------------

max_num_objects=85
*=$900
object_types:
                .fill max_num_objects
object_addrs_lo:
                .fill max_num_objects
object_addrs_hi:
                .fill max_num_objects
object_var0s:
                .fill max_num_objects
object_var1s:
                .fill max_num_objects
object_var2s:
                .fill max_num_objects
                .cerror *>$b00,format('object tables overflow')
                
;-------------------------------------------------------------------------

                .if editor
*=gedmc_org
                .else
*=gmc_org
                .endif

;-------------------------------------------------------------------------

gmc_start:
                
                .if editor
                ; C64 files don't have separate load and exec
                ; addresses.
                jmp ed_entry
                jmp ed_mul_test ; cheezy crap for BASIC test
                .endif

sprite_blank:
                .fill 16,0
sprite_block:
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %11111111
                .byte %10001000
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %10001000
                .byte %11111111
sprite_lblock:
                .byte %11111111
                .byte %10011001
                .byte %01110111
                .byte %01100110
                .byte %00100010
                .byte %00110011
                .byte %00010001
                .byte %00000000
                .byte %11111111
                .byte %10001000
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %10001000
                .byte %01110111
sprite_rblock:
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %01100110
                .byte %01100110
                .byte %11111111
                .byte %00010001
                .byte %11111111
                .byte %11111111
                .byte %10011001
                .byte %11101110
                .byte %01100110
                .byte %01000100
                .byte %11001100
                .byte %10001000
                .byte %00000000
sprite_spikes:
                .byte %00001001
                .byte %00001001
                .byte %00001001
                .byte %00001101
                .byte %00001101
                .byte %00000101
                .byte %00000101
                .byte %00001111
                .byte %00001001
                .byte %00001001
                .byte %00001001
                .byte %00001011
                .byte %00001011
                .byte %00001010
                .byte %00001010
                .byte %00001111
sprite_spring_row0:
                .byte %00001010
                .byte %00001111
                .byte %00000000
                .byte %00000111
                .byte %00001000
                .byte %00000111
                .byte %00000000
                .byte %00000111
                .byte %00001010
                .byte %00001100
                .byte %00000010
                .byte %00001001
                .byte %00000101
                .byte %00001110
                .byte %00000010
                .byte %00001001
sprite_spring_row1:
                .byte %00001000
                .byte %00000111
                .byte %00000000
                .byte %00000111
                .byte %00001000
                .byte %00000111
                .byte %00001000
                .byte %00000111
                .byte %00000101
                .byte %00001110
                .byte %00000010
                .byte %00001001
                .byte %00000101
                .byte %00001110
                .byte %00000001
                .byte %00001110
sprite_dots:
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00110000
                .byte %00110000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %00110000
                .byte %00110000
                .byte %00000000
                .byte %00000000
                
sprite_pl_right_0:.byte 0, $30, $70, $50,$F0,$E0,$F0, $70, 0, 0, $80,$C0, $80, 0, 0,$C0, $70, $30, $30, $20, $20,$C0, $80, 0, $80, 0, $80, $80,$C0, $80, 0, 0; 0
sprite_pl_right_1:.byte 0, 0, $10, $10, $30, $30, $30, $10, 0,$C0,$E0, $60,$F0, $80,$F0,$E0, $10, 0, 0, 0, 0, 0, 0, 0,$E0,$C0,$C0,$C0,$C0, $80, $80,$C0; 0
sprite_pl_left_0:.byte 0, 0, $10, $30, $10, 0, 0, $30, 0,$C0,$E0,$A0,$F0, $70,$F0,$E0, $10, 0, $10, $10, $30, $10, 0, 0,$E0,$C0,$C0, $40, $40, $30, $10, 0; 0
sprite_pl_left_1:.byte 0, $30, $70, $60,$F0, $10,$F0, $70, 0, 0, $80, $80,$C0,$C0,$C0, $80, $70, $30, $30, $30, $30, $10, $10, $30, $80, 0, 0, 0, 0, 0, 0, 0; 0
sprite_pl_facing:.byte $10, $30, $10, $70, $40, $60, $30, $30, $80,$C0, $80,$E0, $20, $60,$C0,$C0, $10, $20, $20, $20, $20, $20, $20, $60, $80, $40, $40, $40, $40, $40, $40, $60; 0
sprite_spider_0_row0:.byte 0, 0, 1, 3, $11, 3, 6, $37, 0, 0, $6E, $77, $77,$FF,$DF,$DF, 0, 0, $67,$EE,$EE,$FF,$BF,$BF, 0, 0, 8, $C, $88, $C, 6,$CE; 0
sprite_spider_0_row1:.byte $33, $13, $17, $15, 5, 1, 0, 0, $57, $77, $77, 2, 2, 9, 8, 8,$AE,$EE,$EE, 4, 4, 9, 1, 1,$CC, $8C, $8E, $8A, $A, 8, 0, 0; 0
sprite_floating_platform:.byte $FF,$FF, $9E, $9E, $56, 7, 8, 8,$FF,$CF,$C3,$CF,$DE, $2C, $1E, 3,$FF, $3F, $3C, $3F,$B7, $43, $87, $C,$FF,$FF, $97, $97,$A6, $E, 1, 1; 0
sprite_goal_row0:.byte $10,$50, $60,$F0, $58, $1E, $F, $F, $20,$D0,$F0,$A0, $70,$D0, $F, $3C, $50,$E0,$B0,$D0, $70,$A0, $F, $87, 0,$C0,$A0, $70,$C1, $87, $F, $F; 0
sprite_goal_row1:.byte $3F, $5C, $6C, $5C, $3F, $F, 7, 1, $3C,$BD,$BD,$BC, $3C, $2D, $2D, $F,$C3,$DB,$DB,$D3, $87, $F, $F, $F,$CF,$A3, $63,$A3,$CF, $F, $E, 8; 0
sprite_conveyor:.byte 0, 0, 0, 0, 0, 0, 0, 0,$FF,$AA, $55, $55,$AA,$AA,$FF, 0; 0
sprite_pl_die_8:.byte 0, $40, $20,$C0, 0, $20, $50, $10, $80,$A0, $40, 0, $30, $40, $20, 0; 0
sprite_pl_splat:.byte 0, 0, 0, $20, $90, $70,$E0,$F0, 0, 0, 0, $40,$C0,$A0,$D0,$F0; 0
sprite_spider_1_row0:.byte $C, $17, $11, 0, $17, $C, $33, $77, 0, 0,$CC, $55,$FF,$FF,$DF,$DF, 0, 0, $33,$AA,$FF,$FF,$BF,$BF, 3, $8E, $88, 0, $8E, 3,$CC,$EE; 0
sprite_spider_1_row1:.byte $55, $5D, $19, $1B, $A, 2, 2, 2, $57, $77, $77, 2, 2, 4, 4, 0,$AE,$EE,$EE, 4, 4, 2, 2, 0,$AA,$AB, $89, $8D, 5, 4, 4, 4; 0
sprite_power_pill:
                .byte %00000000
                .byte %00000000
                .byte %00010000
                .byte %00100001
                .byte %00100001
                .byte %00100001
                .byte %00010000
                .byte %00000000
                .byte %00000000
                .byte %00000000
                .byte %10000000
                .byte %01001000
                .byte %01001000
                .byte %01001000
                .byte %10000000
                .byte %00000000

                
sprite_ghost_angry_row0:.byte 3, 7, 7, $69, $49, $49, $F, $F, $C, $E, $E, $69, $29, $29, $F, $F; 0
sprite_ghost_angry_row1:.byte $E, 4, 4, 5, 3, 3, 3, $F, 7, 3, 2, $A, $E, $C, $C, 0; 0
sprite_ghost_happy_row0:.byte 3, 7, 7, $49, $49, $69, $F, $F, $C, $E, $E, $29, $29, $69, $F, $F; 0
sprite_ghost_happy_row1:.byte $D, 5, 4, 6, 3, $B, $F, 7, $B, $B, 2, 6, $E, $C, $C, 8; 0
sprite_pl_die_0:.byte $10, $30, $30, $70, $70, $30, $30, $10, $80,$C0,$C0,$E0,$E0,$C0,$C0, $80; 0
sprite_pl_die_1:.byte 0, $20, $20, $60, $70, $30, $30, $10, 0, $40, $40, $60,$E0,$C0,$C0, $80; 0
sprite_pl_die_2:.byte 0, 0, $40, $60, $70, $30, $30, $10, 0, 0, $20, $60,$E0,$C0,$C0, $80; 0
sprite_pl_die_3:.byte 0, 0, 0, 0, $70, $30, $30, $10, 0, 0, 0, 0,$E0,$C0,$C0, $80; 0
sprite_pl_die_4:.byte 0, 0, 0, 0, $30, $70, $30, $10, 0, 0, 0, 0,$C0,$E0,$C0, $80; 0
sprite_pl_die_5:.byte 0, 0, 0, 0, $10, $10, $10, $10, 0, 0, 0, 0, $80, $80, $80, $80; 0
sprite_pl_die_6:.byte 0, 0, 0, 0, $10, $10, 0, 0, 0, 0, 0, 0, $80, $80, 0, 0; 0
sprite_pl_die_7:.byte 0, 0, $20, $10, $10, $20, 0, 0, 0, 0, $40, $80, $80, $40, 0, 0; 0
sprite_alt_goal_row1:.byte $69, $3C, $3C, $69, $F, $F, 7, 0, $3E, $2F, $2F, $3F, $3E, $2F, $2D, $F,$C7, $4F, $4F,$CB, $87, $F, $F, $F, $69,$C3,$C3, $69, $F, $F, $E, 0; 0

envelope: .macro n,len,pcr1,pcr2,pcr3,pl1,pl2,pl3,aacr,dacr,sacr,racr,atl,dtl
                .byte \n
                .char \len
                .char \pcr1,\pcr2,\pcr3
                .byte \pl1,\pl2,\pl3
                .char \aacr,\dacr,\sacr,\racr
                .char \atl,\dtl
                .endmacro
                
envelopes:
                .envelope 1,1,0,0,0,0,0,200,0,0,0,-2,126,0
                .envelope 2,2,1,-1,1,2,4,2,1,0,0,-1,100,0
                .envelope 3,3,20,-20,8,5,5,5,0,0,0,-1,110,0
                .envelope 4,2,0,0,0,0,0,255,3,0,0,-126,127,0 
                
; footstep
L0AC0:
                .word $11       ; channel
                .word $FFF1     ; amplitude
                .word $FF       ; pitch
                .word 0         ; duration

; jump?
L0AC8:                         
                .word $10; channel
                .word 1         ; amplitude
                .word 2         ; pitch
                .word 1         ; duration
; low beep
L0AD0:
                .word $13; channel
                .word $FFF1     ; amplitude
                .word 0         ; pitch
                .word 3         ; duration

; spooky background noise
L0AD8:
                .word $12; channel
                .word 2         ; amplitude
                .word 5         ; pitch
                .word $32       ; duration

; dot eaten
L0AE0:
                .word $13; channel
                .word 3         ; amplitude
                .word $30       ; pitch
                .word 5         ; duration
                .byte 0
                .byte 0
bonus_update_timer:.byte 2
;spider_speed: .byte $C
;spider_update_timer: .byte $4D
;spider_direction: .byte 1
L0AEE: .byte 0                  ;some kind of sound timer
;conveyor_direction: .byte 1
;conveyor_update_timer: .byte $4D
L0AF1: .byte 1                  ;update timer of some kind
L0AF2: .byte $3C
L0AF3: .byte 0                  ;unused???
L0AF4: .byte $85
platform_speed:.byte 6
             .byte 1
L0AF7: .byte $B0,$72            ;backup of player sprite address
;platform_update_timer:.byte 1
;platform_direction: .byte 0
player_update_timer:.byte 2
L0AFC: .byte 0                  ;???
player_movement:.byte 2
player_jump_state:.byte 0
player_anim_frame:.byte 0

update_object_index: .byte 0

level_finished: .byte 0
                
ghosts_table:   .word $6A28
                .word 0
                .word 0
                .word 0
                .byte $48       ; H

; type_chars:
;                 .byte ' '       ;blank
;                 .byte $e2       ;lblock
;                 .byte $e3       ;rblock
;                 .byte $e0       ;block
;                 .byte 

;-------------------------------------------------------------------------

num_objects:
                .byte 0
                
;-------------------------------------------------------------------------

reset_envelopes: .block
                ; level_draw_ptr safe to reuse
                lda #<envelopes
                sta level_draw_ptr
                lda #>envelopes
                sta level_draw_ptr+1

                ldx #4

loop:
                txa
                pha
                
                ldx level_draw_ptr+0
                ldy level_draw_ptr+1
                lda #8          ;define envelope
                jsr osword

                clc
                lda level_draw_ptr+0
                adc #14
                sta level_draw_ptr+0
                bcc +
                inc level_draw_ptr+1
+

                pla
                tax
                dex
                bne loop
                
                rts
                .endblock

;-------------------------------------------------------------------------

make_otype: .function ltypes_begin,ltypes_end,sprite_data,sprite_width,sprite_height,init_routine,update_routine,ed_flags
                .cerror !(sprite_width==1||sprite_width==2),'invalid sprite width'
                .cerror !(sprite_height==1||sprite_height==2),'invalid sprite height'
                
_otype_flags:=0
                .if sprite_width==2
_otype_flags:=_otype_flags|otype_flags_width2
                .endif

                .if sprite_height==2
_otype_flags:=_otype_flags|otype_flags_height2
                .endif

                .endfunction {.ltypes_begin:ltypes_begin,.ltypes_end:ltypes_end,.sprite_data:sprite_data,.otype_flags:_otype_flags,.init_routine:init_routine,.update_routine:update_routine,.ed_flags:ed_flags}

make_sta_otype: .function ltype,sprite_data,sprite_width,sprite_height,ed_flags=0
                .endfunction make_otype(ltype,ltype+1,sprite_data,sprite_width,sprite_height,0,0,ed_flags)

make_dyn_otype: .function base_ltype,num_ltypes,sprite_data,sprite_width,sprite_height,init_routine,update_routine,ed_flags=0
                .endfunction make_otype(base_ltype,base_ltype+num_ltypes,sprite_data,sprite_width,sprite_height,init_routine,update_routine,ed_flags)

_:=[]
_..=[make_sta_otype(type_blank.index,0,1,1,ed_flags_repeat)]
_..=[make_sta_otype(type_lblock.index,sprite_lblock,1,1)]
_..=[make_sta_otype(type_rblock.index,sprite_rblock,1,1)]
_..=[make_sta_otype(type_block.index,sprite_block,1,1,ed_flags_repeat)]
_..=[make_sta_otype(type_spikes.index,sprite_spikes,1,1)]
_..=[make_sta_otype(type_spring_1_row.index,sprite_spring_row0,1,1)]
_..=[make_sta_otype(type_spring_2_rows.index,sprite_spring_row0,1,2)]
_..=[make_sta_otype(type_dots.index,sprite_dots,1,1,ed_flags_repeat)]
_..=[make_sta_otype(type_pill.index,sprite_power_pill,1,1)]
otype_conveyor=len(_)           ;temp
_..=[make_dyn_otype(type_conveyor.index,1,sprite_conveyor,1,1,0,update_conveyor)]
otype_platform=len(_)           ;temp
_..=[make_dyn_otype(type_platform.index,num_speeds,sprite_floating_platform,2,1,0,update_platform)]
otype_spider=len(_)             ;temp
_..=[make_dyn_otype(type_spider.index,num_speeds,sprite_spider_0_row0,2,2,0,update_spider)]
_..=[make_dyn_otype(type_spider2.index,num_speeds,sprite_spider_0_row0,2,2,0,update_spider,ed_flags_masked)]
otypes=_

otypes_ltype_begin:
                .byte otypes.ltypes_begin
otypes_ltype_end:
                .byte otypes.ltypes_end
otypes_sprite_data_lo:
                .byte <otypes.sprite_data
otypes_sprite_data_hi:
                .byte >otypes.sprite_data
otypes_init_routine_lo:
                .byte <otypes.init_routine
otypes_init_routine_hi:
                .byte >otypes.init_routine
otypes_update_routine_lo:
                .byte <otypes.update_routine
otypes_update_routine_hi:
                .byte >otypes.update_routine
otypes_otype_flags:
                .byte otypes.otype_flags
otypes_ed_flags: .proc
                .byte otypes.ed_flags
                .endproc

;-------------------------------------------------------------------------
                
entry_init_level: .block
game_start_y=4
game_start_addr=$5800+game_start_y*320
level_name_y=28

                stx go

                lda #0
                sta num_objects
                ; sta conveyor_addr+1
                ; sta spider_addr+1
                ; sta platform_addr+1
                
                lda #31
                jsr oswrch
                lda #0
                jsr oswrch
                lda #game_start_y
                jsr oswrch

                lda #<game_start_addr
                sta level_draw_screen_addr+0
                lda #>game_start_addr
                sta level_draw_screen_addr+1

                lda #$ff
                sta colour

                lda #<-(level_width*level_height)
                sta counter+0
                lda #>-(level_width*level_height)
                sta counter+1

loop:
                ldy #LevelData.map ;get the addition for free...
                lda (level_draw_ptr),y

                ldx #0
find_loop:
                ldy item_info,x
                cpy #$ff
                beq not_found
                
                cmp item_info,x
                beq found

                inx
                inx
                inx
                jmp find_loop

not_found:
                cmp #type_spring_2_rows.index
                beq spring_2_rows
                
                cmp #type_pill.index
                beq pill

                cmp #type_conveyor.index
                beq conveyor

                cmp #type_platform.index
                bcc +
                cmp #type_platform.index+num_speeds
                bcc platform
+
                
                cmp #type_spider.index
                bcc +
                cmp #type_spider.index+num_speeds
                bcc spider
+

                cmp #type_spider2.index
                bcc +
                cmp #type_spider2.index+num_speeds
                bcc spider2
+
                
next:
                ; pretend it was blank.
                ldx #0
                
found:
                lda #17
                jsr oswrch
                lda item_info+1,x
                jsr oswrch
                lda item_info+2,x
                jsr oswrch

                inc level_draw_ptr+0
                bne +
                inc level_draw_ptr+1
+
                
                clc
                lda level_draw_screen_addr+0
                adc #16
                sta level_draw_screen_addr+0
                bcc +
                inc level_draw_screen_addr+1
+

                inc counter+0
                bne loop
                inc counter+1
                bne loop
                
done:
; The BASIC code ends up clearing a bunch of extra stuff due to
; slightly careless-looking use of !.
                lda #0
                sta object_addr+2
                sta object_addr+3
                sta object_addr+4
                sta was_platform_addr+2
                sta was_platform_addr+3
                sta was_platform_addr+4

                rts

spring_2_rows:
                ldx #0
spring_2_rows_loop:
                lda spring_2_rows_data,x
                jsr oswrch
                inx
                cpx #size(spring_2_rows_data)
                bne spring_2_rows_loop
                jmp next
spring_2_rows_data: .block
                .text 17,1,$e1,8,10,$e5,11,8
                .endblock
                
platform:
                ldy #otype_platform
                jsr add_object
                sec
                sbc #type_platform.index
                sta object_var1s,x ;speed
                sta object_var2s,x ;update timer
                lda #0
                sta object_var0s,x ;direction

                ldy #31
platform_loop:
                lda sprite_floating_platform,y
                sta (level_draw_screen_addr),y
                dey
                bpl platform_loop
                jmp next
                
conveyor:
                ldy #otype_conveyor
                jsr add_object
                lda #2
                sta object_var2s,x ;update timer
                lda #1
                sta object_var0s,x ;direction

                ldy #15
conveyor_loop:
                lda sprite_conveyor,y
                sta (level_draw_screen_addr),y
                dey
                bpl conveyor_loop
                jmp next
                
pill:
                ldy #15
pill_loop:
                lda sprite_power_pill,y
                sta (level_draw_screen_addr),y
                dey
                bpl pill_loop
                jmp next

spider2:
                ldx go
                beq next
                sec
                sbc #type_spider2.index
                jmp spider_common
                
spider:
                sec
                sbc #type_spider.index
spider_common:
                ldy #otype_spider
                jsr add_object
                sta object_var1s,x ;speed
                sta object_var2s,x ;update timer
                lda #1
                sta object_var0s,x ;direction

                clc
                lda level_draw_screen_addr+0
                adc #$40
                sta L0074+0
                lda level_draw_screen_addr+1
                adc #$01
                sta L0074+1
                ldy #31
spider_loop:
                lda sprite_spider_0_row0,y
                sta (level_draw_screen_addr),y
                lda sprite_spider_0_row1,y
                sta (L0074),y
                dey
                bpl spider_loop
                
                jmp next

add_object:
                pha
                
                ldx num_objects
                cpx #max_num_objects
                bne +
                
                ; oops! maxed out. reuse the last slot.
                dex
                stx num_objects
+
                inc num_objects

                tya
                sta object_types,x
                lda level_draw_screen_addr+0
                sta object_addrs_lo,x
                lda level_draw_screen_addr+1
                sta object_addrs_hi,x

                pla
                rts
                
go:
                .byte 0
colour:
                .byte 0
counter:
                .word 0
                .endblock

item_info_entry: .macro item
                .byte \item.index,\item.colour,\item.char
                .endmacro
                
item_info:
                .item_info_entry type_blank
                .item_info_entry type_lblock
                .item_info_entry type_rblock
                .item_info_entry type_block
                .item_info_entry type_spikes
                .item_info_entry type_dots
                .item_info_entry type_spring_1_row
                .byte $ff

; C=0 on exit if found. X refers to item info table entry.
find_item_info: .proc
                ldx #0
loop:
                ldy item_info,x
                cpy #$ff
                beq not_found
                cmp item_info,x
                beq found
                inx
                inx
                inx
                jmp loop
found:
                clc
not_found:
                rts
                .endproc
                
;-------------------------------------------------------------------------

; copy of what was behind player
data_behind_player:
                .fill 32

;-------------------------------------------------------------------------

                .byte 0
                .byte 0
bonus_chars:    .byte 234, 238; 0
                .byte 'E'
                .byte 'S'
                .byte 'T'
                .byte 'S'
                .byte 134
                .byte '1'
                .byte 'G'
                .byte 'H'
                .byte 'O'
                .byte 'S'
                .byte 'T'
                .byte ' '
                .byte ' '
                .byte '$'
score_chars:    .byte 230, 230, 230, 238, 232; 0
                .byte ' '
                .byte ' '
                .byte '$'
                .byte 'R'
                .byte 'O'
                .byte 'B'
                .byte 'O'
                .byte 'T'
                .byte ' '
L0E1E:       .byte ' '
                .byte '$'

;-------------------------------------------------------------------------

entry_game:
                lda #1
                ; sta spider_direction
                ; sta conveyor_direction
                sta player_anim_frame
                lda #0
                sta level_finished
                sta L0AEE
                sta player_jump_state
                ; sta platform_direction
                sta L0AF3
                lda #2
                sta player_movement
                sta player_update_timer
                ; sta platform_update_timer
                sta L0AF1
                ; sta conveyor_update_timer
                ; sta spider_update_timer
                lda #$1F
                sta bonus_update_timer

main_loop:
                ; TODO what is this? random number type of thing?
                lda L0AF4
                adc player_addr
                adc was_platform_addr
                adc L007C
                sta L0AF4
                jsr update_player
                jsr L1205

                ldx #$ff
                
update_objects_loop:
                inx
                cpx num_objects
                beq update_objects_done

                stx update_object_index
                
                lda object_addrs_lo,x
                sta object_addr+0
                lda object_addrs_hi,x
                sta object_addr+1
                
                ldy object_types,x
                
                lda otypes_update_routine_lo,y
                sta jsr_object_update+1
                lda otypes_update_routine_hi,y
                sta jsr_object_update+2

jsr_object_update: jsr $ffff

                ldx update_object_index
                lda object_addr+0
                sta object_addrs_lo,x
                lda object_addr+1
                sta object_addrs_hi,x

                jmp update_objects_loop
update_objects_done:
                ; jsr update_platform
                ; jsr update_conveyor
                ; jsr update_spider
                
                ldx #inkey(key_p)
                jsr test_key
                beq L0E85

pause_loop:
                ldx #inkey(key_o)
                jsr test_key
                beq pause_loop

L0E85:
                lda #19
                jsr osbyte

                ldx #inkey(key_escape)
                jsr test_key
                beq main_loop
                rts

;-------------------------------------------------------------------------

update_player: .block

                dec player_update_timer
                lda player_update_timer
                beq L0EA8
                rts

;-------------------------------------------------------------------------

L0EA8:
                lda #2
                sta player_update_timer
                dec bonus_update_timer
                lda bonus_update_timer
                bne L0EBD
                lda #$1F
                sta bonus_update_timer
                jsr update_bonus

L0EBD:
                lda player_addr
                sta L0072
                sta L0AF7
                clc
                adc #$40
                sta L0074
                lda player_addr+1
                sta L0072+1
                sta L0AF7+1
                adc #1
                sta L0075
                jmp L1521
                .endblock

;-------------------------------------------------------------------------

L0ED7:
                jmp L1490

;-------------------------------------------------------------------------

L0EDA:
                lda #0
                sta player_movement
                ldx #inkey(key_x)
                jsr test_key
                beq test_z_key
; X pressed
                lda player_movement
                bne L0EF8
                lda #<sprite_pl_right_0
                sta L0078
                lda #>sprite_pl_right_0
                sta L0079

L0EF8:
                lda #1          ; 1=right
                sta player_movement
                jmp L0F1E

;-------------------------------------------------------------------------

test_z_key:
                ldx #inkey(key_z)
                jsr test_key
                beq L0F1E
                lda player_movement
                bne L0F19
                lda #<sprite_pl_left_0
                sta L0078
                lda #>sprite_pl_left_0
                sta L0079

L0F19:
                lda #2          ; 2=left
                sta player_movement

L0F1E:
                lda player_movement
                bne L0F2E
                lda #<sprite_pl_facing
                sta L0078
                lda #>sprite_pl_facing
                sta L0079
                jmp L1158

;-------------------------------------------------------------------------

L0F2E:
                lda player_anim_frame
                eor #1
                sta player_anim_frame
                bne L0F51
; select next anim frame sprite
                lda L0078
                clc
                adc #$20
                sta L0078
                lda L0079
                adc #0
                sta L0079
                lda #7
                ldx #<L0AC0
                ldy #>L0AC0
                jsr osword
                jmp L1158

;-------------------------------------------------------------------------

L0F51:
                lda player_movement
                cmp #2
                beq move_player_left; taken if moving left
                cmp #1
                bne L0F89     ; taken if stationary
; moving right
                lda player_addr
                clc
                adc #8
                sta player_addr
                lda player_addr+1
                adc #0
                sta player_addr+1
                lda #<sprite_pl_right_0
                sta L0078
                lda #>sprite_pl_right_0
                sta L0079
                jmp L0F89

;-------------------------------------------------------------------------

move_player_left:
                lda player_addr
                sec
                sbc #8
                sta player_addr
                lda player_addr+1
                sbc #0
                sta player_addr+1
                lda #<sprite_pl_left_0
                sta L0078
                lda #>sprite_pl_left_0
                sta L0079

L0F89:
                ldy #$F

copy_screen_behind_player_loop:
                lda data_behind_player,y  ; copy of what was under player, row 0?
                sta (L0072),y
                lda data_behind_player+16,y  ; copy of what was under player, row 1?
                sta (L0074),y
                dey
                bpl copy_screen_behind_player_loop

                ; Check for power pill
                ldy #15
check_power_pill_loop:
                lda data_behind_player,y
                cmp sprite_power_pill,y
                bne L101C       ;not power pill
                dey
                bpl check_power_pill_loop
                
                ; It was the power pill.
                lda #6
                sta L0AC8+4  ;pitch
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword
                lda #2
                sta L0AC8+4  ;pitch
                ldy #$F
                lda #0

L0FBF:
                sta (L0072),y
                sta data_behind_player,y  ; copy of what was under player, row 0?
                dey
                bne L0FBF
                lda #100
                sta L0AEE
                ldx #100
                jsr add_X_to_score
                lda #4
                sta L0AF4    ; ghost index

erase_ghosts_loop:
                ldy L0AF4
                lda ghosts_table,y
                sta L0072
                lda ghosts_table+1,y
                sta L0072+1
                beq erase_ghosts_next; taken if no ghost
                lda L0072
; form screen address for ghost row 1
                clc
                adc #$40
                sta L0074
                lda L0072+1
                adc #1
                sta L0075
                ldy #$F

erase_ghost_loop:
                lda (L0072),y
                cmp sprite_ghost_angry_row0,y
                bne erase_ghost_row1
                lda #0
                sta (L0072),y

erase_ghost_row1:
                lda (L0074),y
                cmp sprite_ghost_angry_row1,y
                bne erase_ghost_next
                lda #0
                sta (L0074),y

erase_ghost_next:
                dey
                bpl erase_ghost_loop

erase_ghosts_next:
                dec L0AF4
                dec L0AF4
                lda L0AF4
                cmp #$FE
                bne erase_ghosts_loop

L101C:
                ; L0072 = player, 2nd row
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                
                lda player_jump_state
                bne L1060
                
                ; lda player_addr
                ; clc
                ; adc #$40
                ; sta L0072
                ; lda player_addr+1
                ; adc #1
                ; sta L0072+1

                ldy #$F
L103D:
                lda (L0072),y
                cmp #mode5_byte(3,3,3,3)
                beq L104B
                dey
                bpl L103D
                jmp L1082

;-------------------------------------------------------------------------

L104B:
                ; Move player up one row.
                lda player_addr
                sec
                sbc #$40
                sta player_addr
                lda player_addr+1
                sbc #1
                sta player_addr+1

                ldx #5
                jsr add_X_to_score
                
                jmp L1082

;-------------------------------------------------------------------------

L1060:
                lda L0072
                clc
                adc #$40
                sta L0072
                lda L0072+1
                adc #1
                sta L0072+1
                ldy #0
                lda (L0072),y
                cmp #mode5_byte(3,3,3,3)
                beq L107D
                ldy #8
                lda (L0072),y
                cmp #mode5_byte(3,3,3,3)
                bne L1082

L107D:
                lda #0
                sta player_jump_state

L1082:
                ldy #$F
                lda (L0074),y
                cmp #mode5_byte(2,2,2,2)
                bne L1092
                lda player_jump_state
                bne L1092
                jmp L158E

;-------------------------------------------------------------------------

copy_data_behind_player:
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L10A1:
                lda (player_addr),y
                sta data_behind_player,y  ; copy of what was under player, row 0?
                lda (L0072),y
                sta data_behind_player+16,y  ; copy of what was under player, row 1?
                dey
                bpl L10A1
                rts
                
L1092:
                jsr copy_data_behind_player
                lda data_behind_player+4  ; copy of what was under player, row 0?
                cmp #mode5_byte(0,0,2,2)
                bne L10DD
                lda #0
                sta data_behind_player+4  ; copy of what was under player, row 0?
                sta data_behind_player+5  ; copy of what was under player, row 0?
                lda L0085
                clc
                adc #4
                sta L0085
                lda L0085
                sta L0AE0+4  ;pitch
                lda #7
                ldx #<L0AE0
                ldy #>L0AE0
                jsr osword
                clc
                ldx #3
                jsr add_X_to_score
                jmp L10E6

;-------------------------------------------------------------------------

L10DD:
                lda player_anim_frame
                bne L10E6
                lda #0
                sta L0085

L10E6:
                ldy #31

L10E8:
                lda data_behind_player,y  ; copy of what was under player, row 1?
                cmp #mode5_byte(1,0,0,0)
                beq L1104
                cmp #mode5_byte(0,0,0,1)
                beq L1104
                cmp #mode5_byte(1,3,3,3)
                beq L1104
                cmp #mode5_byte(3,3,3,1)
                beq L1104
                dey
                bne L10E8
                jmp L1131

;-------------------------------------------------------------------------

; bump up against left or right edge
L1104:
                ldy #$F
                lda #0

L1108:
                sta data_behind_player+16,y  ; copy of what was under player, row 1?
                sta data_behind_player,y  ; copy of what was under player, row 0?
                dey
                bpl L1108

                lda L0AF7
                sta player_addr
                lda L0AF7+1
                sta player_addr+1
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword
                lda player_anim_frame
                eor #1
                sta player_anim_frame
                jmp L1082

;-------------------------------------------------------------------------

L1131:
                ldy #$F

L1133:
                lda (player_addr),y
                beq L114B
                cmp #mode5_byte(0,0,0,2)
                bcs L114B

L113B:
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                jmp L16B4

;-------------------------------------------------------------------------

L114B:
                lda (L0072),y
                beq L1153
                cmp #mode5_byte(0,0,0,2)
                bcc L113B

L1153:
                dey
                bpl L1133

L1158:
                lda L0078
                clc
                adc #$10
                sta L0074
                lda L0079
                adc #0
                sta L0075
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L1174:
                lda (player_addr),y
                beq L117F
                cmp #mode5_byte(1,1,1,1)
                bcs L117F

L117C:
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L117F:
                lda (L0072),y
                beq L1187
                cmp #mode5_byte(1,1,1,1)
                bcc L117C

L1187:
                dey
                bpl L1174
                ldy #$F

L118E:
                lda (L0078),y
                sta (player_addr),y
                lda (L0074),y
                sta (L0072),y
                dey
                bpl L118E
                rts

;-------------------------------------------------------------------------

update_platform:       .block
                ; lda platform_addr+1
                ; beq L11A9       ;skip if no platform
                dec object_var2s,x ; platform_update_timer
                beq L11AA       ;taken if time to update platform

L11A9:
                rts

;-------------------------------------------------------------------------

L11AA:
                lda object_var1s,x;platform_speed
                sta object_var2s,x;platform_update_timer
                ldy #$1F
                lda #0

L11B4:
                sta (object_addr),y
                dey
                bpl L11B4

L11BB:
                lda object_var0s,x;platform_direction
                jsr object_addr_left_or_right
                
                ldy #$1F

L11DF:
                lda (object_addr),y

                ; Change dir if bumping into wall
                cmp #mode5_byte(3,3,3,3)
                beq change_platform_direction

                ; Change dir if bumping into left border
                cmp #mode5_byte(1,0,0,0)
                beq change_platform_direction

                ; Change dir if bumping into right border
                cmp #mode5_byte(0,0,0,1)
                beq change_platform_direction
                
                dey
                bpl L11DF
                jmp draw_floating_platform

;-------------------------------------------------------------------------

change_platform_direction:
                lda object_var0s,x
                eor #1
                sta object_var0s,x
                jmp L11BB
                .endblock

;-------------------------------------------------------------------------

draw_floating_platform:
                ldy #$1F

L11FA:
                lda sprite_floating_platform,y
                sta (object_addr),y
                dey
                bpl L11FA
                rts

;-------------------------------------------------------------------------

L1205:       .block

                dec L0AF1
                lda L0AF1
                beq L1210
                jmp L1386

;-------------------------------------------------------------------------

L1210:
                lda L0AEE
                cmp #$55
                bcc L1237
                dec L0AEE
                lda L0AEE
                sta L0AD8+4  ;pitch
                lda #7
                ldx #<L0AD8
                ldy #>L0AD8
                jsr osword
                lda L0AF2
                sta L0AF1
                ldx #5
                jsr add_X_to_score
                jmp L1386

;-------------------------------------------------------------------------

L1237:
                lda #4
                sta L0AF1

L123C:
                ldy L0AF1
                lda ghosts_table,y
                sta L007E
                lda ghosts_table+1,y
                sta L007F
                lda L007E
                sta L0072
                lda L007F
                sta L0072+1
                bne L1256
                jmp L1370

;-------------------------------------------------------------------------

L1256:
                lda L007E
                sec
                sbc #$80
                sta L0074
                lda L007F
                sbc #0
                sta L0075
                lda player_addr
                sec
                sbc #$80
                sta L0076
                lda player_addr+1
                sbc #0
                sta L0077

L1270:
                lda L0074
                cmp #$40
                lda L0075
                sbc #1
                bcc L128A
                lda L0074
                sec
                sbc #$40
                sta L0074
                lda L0075
                sbc #1
                sta L0075
                jmp L1270

;-------------------------------------------------------------------------

L128A:
                lda L0076
                cmp #$40
                lda L0077
                sbc #1
                bcc L12A4
                lda L0076
                sec
                sbc #$40
                sta L0076
                lda L0077
                sbc #1
                sta L0077
                jmp L128A

;-------------------------------------------------------------------------

L12A4:
                lda L0074
                cmp L0076
                bne L12AB
                clc

L12AB:
                lda L0075
                sbc L0077
                bcc L12C1
                lda L007E
                sec
                sbc #8
                sta L007E
                lda L007F
                sbc #0
                sta L007F
                jmp L1301

;-------------------------------------------------------------------------

L12C1:
                lda L0074
                cmp L0076
                beq L12D7
                lda L007E
                clc
                adc #8
                sta L007E
                lda L007F
                adc #0
                sta L007F
                jmp L1301

;-------------------------------------------------------------------------

L12D7:
                lda L007E
                cmp player_addr
                bne L12DE
                clc

L12DE:
                lda L007F
                sbc player_addr+1
                bcc L12F4
                lda L007E
                sec
                sbc #$40
                sta L007E
                lda L007F
                sbc #1
                sta L007F
                jmp L1301

;-------------------------------------------------------------------------

L12F4:
                lda L007E
                clc
                adc #$40
                sta L007E
                lda L007F
                adc #1
                sta L007F

L1301:
                lda L0072
                clc
                adc #$40
                sta L0074
                lda L0072+1
                adc #1
                sta L0075
                ldy #$F

L1310:
                lda (L0072),y
                cmp sprite_ghost_angry_row0,y
                bne L131B
                lda #0
                sta (L0072),y

L131B:
                lda (L0074),y
                cmp sprite_ghost_angry_row1,y
                bne L1326
                lda #0
                sta (L0074),y

L1326:
                dey
                bpl L1310
                lda L007E
                clc
                adc #$40
                sta L0074
                lda L007F
                adc #1
                sta L0075
                ldy #$F

L133A:
                lda (L007E),y
                cmp #mode5_byte(0,0,2,0)
                bne L1343
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L1343:
                cmp #0
                bne L134C
                lda sprite_ghost_angry_row0,y
                sta (L007E),y

L134C:
                lda (L0074),y
                cmp #mode5_byte(0,0,2,0)
                bne L1355
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L1355:
                cmp #0
                bne L135E
                lda sprite_ghost_angry_row1,y
                sta (L0074),y

L135E:
                dey
                bpl L133A
                ldy L0AF1
                lda L007E
                sta ghosts_table,y
                lda L007F
                sta ghosts_table+1,y

L1370:
                dec L0AF1
                dec L0AF1
                lda L0AF1
                cmp #$FE
                beq L1380
                jmp L123C

;-------------------------------------------------------------------------

L1380:
                lda L0AF2
                sta L0AF1

L1386:
                lda L0AEE
                cmp #$54
                bcs L13A8
                lda L0AF4
                cmp #3
                bcs L13A8
                rol L0AF4
                lda L0AF4
                adc #1
                sta L0AD8+4  ;pitch
                lda #7
                ldx #<L0AD8
                ldy #>L0AD8
                jsr osword

L13A8:
                rts
                .endblock

;-------------------------------------------------------------------------

update_conveyor:       .block
                dec object_var2s,x;conveyor_update_timer
                beq L13AF

L13AE:
                rts

;-------------------------------------------------------------------------

L13AF:
                ; lda conveyor_addr+1
                ; beq L13AE       ;taken if no conveyor on this level
                lda #4
                sta object_var2s,x;conveyor_update_timer
                jsr L156B
                ldy #$F

L13BD:
                lda (object_addr),y
                cmp #mode5_byte(0,3,3,0)
                beq L13CB
                cmp #mode5_byte(1,0,0,0) ; left border
                beq L13CB
                dey
                bpl L13BD
                jmp draw_conveyor

;-------------------------------------------------------------------------

L13CB:
                lda object_var0s,x;conveyor_direction
                eor #1
                sta object_var0s,x;conveyor_direction
                jsr L156B

                ; fall through
                .endblock

draw_conveyor:
                ldy #$F

L13D8:
                lda sprite_conveyor,y
                sta (object_addr),y
                dey
                bpl L13D8
                rts

;-------------------------------------------------------------------------

L156B:       .block
                lda object_var0s,x;conveyor_direction
                jmp object_addr_left_or_right
                .endblock


;-------------------------------------------------------------------------

update_spider:       .block
                dec object_var2s,x;spider_update_timer
                lda object_var2s,x;spider_update_timer
                beq L13EE

L13EB:
                jmp L148F

;-------------------------------------------------------------------------

L13EE:
                ; lda spider_addr+1
                ; beq L13EB
                lda object_var1s,x;spider_speed
                sta object_var2s,x;spider_update_timer
                lda object_addr+0
                clc
                adc #$40
                sta L0072
                lda object_addr+1
                adc #1
                sta L0072+1
                lda #0
                ldy #$1F

L1409:
                sta (object_addr),y
                sta (L0072),y
                dey
                bpl L1409

L1412:
                lda object_var0s,x;spider_direction
                and #1
                jsr object_addr_up_or_down
                
                lda object_addr
                clc
                adc #$40
                sta L0072
                lda object_addr+1
                adc #1
                sta L0072+1
                ldy #$1F

L1443:
                lda (L0072),y
                cmp #mode5_byte(3,3,3,3)
                beq L1457
                cmp #mode5_byte(2,0,2,0)
                beq L1457
                lda (object_addr),y
                cmp #mode5_byte(3,3,3,3)
                beq L1457
                cmp #mode5_byte(2,0,2,0)
                beq L1457
                dey
                bpl L1443
                jmp L1462

;-------------------------------------------------------------------------

L1457:
                lda object_var0s,x;spider_direction
                eor #1
                sta object_var0s,x;spider_direction
                jmp L1412

;-------------------------------------------------------------------------

L1462:
                lda object_var0s,x;L0084
                eor #2
                sta object_var0s,x;L0084
                and #2
                beq L147E
                ldy #$1F

L146C:
                lda sprite_spider_0_row0,y
                sta (object_addr),y
                lda sprite_spider_0_row1,y
                sta (L0072),y
                dey
                bpl L146C
                rts

;-------------------------------------------------------------------------

L147E:
                ldy #$1F

L1480:
                lda sprite_spider_1_row0,y
                sta (object_addr),y
                lda sprite_spider_1_row1,y
                sta (L0072),y
                dey
                bpl L1480

L148F:
                rts
                .endblock

;-------------------------------------------------------------------------

object_addr_left_or_right:
                cmp #0
                beq object_addr_right
                ; fall through
object_addr_left: 
                sec
                lda object_addr+0
                sbc #8
                sta object_addr+0
                bcs +
                dec object_addr+1
+
                rts

object_addr_right:
                clc
                lda object_addr+0
                adc #8
                sta object_addr+0
                bcc +
                inc object_addr+1
+
                rts

object_addr_up_or_down:
                cmp #0
                beq object_addr_down
                ; fall through
object_addr_up:
                sec
                lda object_addr+0
                sbc #$40
                sta object_addr+0
                lda object_addr+1
                sbc #$01
                sta object_addr+1
                rts

object_addr_down:
                clc
                lda object_addr+0
                adc #$40
                sta object_addr+0
                lda object_addr+1
                adc #$01
                sta object_addr+1
                rts
                
;-------------------------------------------------------------------------

L1490:
                lda player_addr
                clc
                adc #$80
                sta L0076
                lda player_addr+1
                adc #2
                sta L0077
                ldy #0
                lda (L0076),y
                cmp #mode5_byte(1,0,1,0)
                beq L14AD
                ldy #8
                lda (L0076),y
                cmp #mode5_byte(1,0,1,0)
                bne L14CA

L14AD:
                lda #6
                sta player_jump_state
                lda #1
                sta L0AC8+4  ;pitch
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword
                lda #2
                sta L0AC8+4  ;pitch
                ldx #3
                jsr add_X_to_score

L14CA:
                ldy #0
                lda (L0076),y
                cmp #mode5_byte(3,3,3,3)
                beq L14FA
                ldy #8
                lda (L0076),y
                cmp #mode5_byte(3,3,3,3)
                beq L14FA
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                jsr L166B
                inc L0AFC
                lda L0AFC
                cmp #4
                bne L14F7
                jmp L16B4

;-------------------------------------------------------------------------

L14F7:
                jmp L0F89

;-------------------------------------------------------------------------

L14FA:
                lda player_jump_state
                bne L1519    ; taken if already jumping
                ldx #inkey(key_return)
                jsr test_key
                beq L1519    ; taken if not pressed
                lda #4
                sta player_jump_state
                lda #7
                ldx #<L0AC8
                ldy #>L0AC8
                jsr osword

L1519:
                lda #0
                sta L0AFC
                jmp L0EDA

;-------------------------------------------------------------------------

L1521:
                lda player_jump_state
                bne L1529
                jmp L0ED7

;-------------------------------------------------------------------------

L1529:
                lda player_anim_frame
                eor #1
                sta player_anim_frame
                lda player_anim_frame
                beq L1539
                jmp L1158

;-------------------------------------------------------------------------

L1539:
                lda player_jump_state
                cmp #3
                bcc L154D    ; taken if 0/1/2
; player_jump_state>=3 - move player up 1 row
                lda player_addr
                sec
                sbc #$40
                sta player_addr
                lda player_addr+1
                sbc #1
                sta player_addr+1

L154D:
                lda player_jump_state
                cmp #1
                beq L1558
                cmp #2
                bne L1565
;player_jump_state<3 - move player down 1 row

L1558:
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1

L1565:
                dec player_jump_state
                jmp L0F51

;-------------------------------------------------------------------------

L158E:
                lda #$FF
                sta level_finished
                lda player_addr
                clc
                adc #$40
                sta L0074
                lda player_addr+1
                adc #1
                sta L0075
                ldy #$F

L15A2:
                lda sprite_pl_facing,y
                sta (player_addr),y
                lda sprite_pl_facing+$10,y
                sta (L0074),y
                dey
                bpl L15A2
                lda bonus_chars+1
                sec
                sbc #230
                beq L15BD
                tax
                jsr add_X_to_score

L15BD:
                lda bonus_chars
                sec
                sbc #230
                tay
                beq L15DD
                lda #0
                sta L0E1E

L15CB:
                lda L0E1E
                clc
                adc #$A
                sta L0E1E
                dey
                bne L15CB
                ldx L0E1E
                jsr add_X_to_score

L15DD:
                pla
                pla
                rts

;-------------------------------------------------------------------------

update_bonus:   .block
                dec bonus_chars+1
                lda bonus_chars+1
                cmp #229
                bne L15FE
                lda #239
                sta bonus_chars+1
                dec bonus_chars
                lda bonus_chars
                cmp #229
                bne L15FE
                pla
                pla
                jmp kill_player_and_drop_caller

;-------------------------------------------------------------------------

L15FE:
                ldy #1
                lda bonus_chars
                cmp #230
                bne L1617
                lda #$95
                sta L0AD0+4  ;pitch
                lda #7
                ldx #<L0AD0
                ldy #>L0AD0
                jsr osword
                ldy #1

L1617:
                lda #31
                jsr oswrch
                tya
                clc
                adc #18
                jsr oswrch
                lda #1
                jsr oswrch
                lda bonus_chars,y
                jsr oswrch
                dey
                bpl L1617
                rts
                .endblock

;-------------------------------------------------------------------------

add_X_to_score: .block
                ldy #4

L1636:
                lda score_chars,y
                clc
                adc #1
                sta score_chars,y
                cmp #240
                bne L164C
                lda #230
                sta score_chars,y
                dey
                jmp L1636

;-------------------------------------------------------------------------

L164C:
                dex
                bne add_X_to_score
                ldy #4

L1651:
                lda #$1F
                jsr oswrch
                tya
                jsr oswrch
                lda #1
                jsr oswrch
                lda score_chars,y
                jsr oswrch
                dey
                bpl L1651
                rts
                .endblock

;-------------------------------------------------------------------------

L166B:       .block
                ldx #5

L166D:
                ldy #4

L166F:
                lda score_chars,y
                sec
                sbc #1
                sta score_chars,y
                cmp #229
                bne L1695
                lda #239
                sta score_chars,y
                dey
                bpl L166F
                ldy #4
                lda #230

L168A:
                sta score_chars,y
                dey
                bpl L168A
                jmp L1698

;-------------------------------------------------------------------------

L1695:
                dex
                bne L166D

L1698:
                ldy #4

L169A:
                lda #$1F
                jsr oswrch
                tya
                jsr oswrch
                lda #1
                jsr oswrch
                lda score_chars,y
                jsr oswrch
                dey
                bpl L169A
                rts
                .endblock

;-------------------------------------------------------------------------

L16B4:
                lda #150
                sta L0AD0+4  ;pitch
                lda player_addr
                sec
                sbc #$40
                sta player_addr
                lda player_addr+1
                sbc #1
                sta player_addr+1

L16C6:
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                dec L0AD0+4  ;pitch
                lda #7
                ldx #<L0AD0
                ldy #>L0AD0
                jsr osword
                jsr L166B
                ldy #$F

L16E4:
                lda data_behind_player,y  ; copy of what was under player, row 0?
                sta (player_addr),y
                lda data_behind_player+16,y  ; copy of what was under player, row 1?
                sta (L0072),y
                dey
                bpl L16E4
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                bmi draw_pl_splat
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L170F:
                lda (player_addr),y
                sta data_behind_player,y  ; copy of what was under player, row 0?
                lda (L0072),y
                sta data_behind_player+16,y  ; copy of what was under player, row 1?
                dey
                bpl L170F
                lda data_behind_player+16    ; copy of what was under player, row 1?
                cmp #mode5_byte(3,3,3,3)
                beq draw_pl_splat
                lda data_behind_player+16+8  ; copy of what was under player, row 1?
                cmp #mode5_byte(3,3,3,3)
                beq draw_pl_splat
                lda L0078
                clc
                adc #$10
                sta L0074
                lda L0079
                adc #0
                sta L0075
                ldy #$F

L173B:
                lda (L0078),y
                sta (player_addr),y
                lda (L0074),y
                sta (L0072),y
                dey
                bpl L173B
                ldx #70

L174A:
                ldy #0

L174C:
                dey
                bne L174C
                dex
                bne L174A
                jmp L16C6

;-------------------------------------------------------------------------

draw_pl_splat:
                ldy #$F

L1757:
                lda sprite_pl_splat,y
                sta (player_addr),y
                dey
                bpl L1757
                lda #0
                sta L0AD0+4  ;pitch
                pla
                pla
                rts

;-------------------------------------------------------------------------

kill_player_and_drop_caller:
                pla
                pla
                lda player_addr
                clc
                adc #$40
                sta L0072
                lda player_addr+1
                adc #1
                sta L0072+1
                ldy #$F

L177A:
                lda data_behind_player,y  ; copy of what was under player, row 0?
                sta (player_addr),y
                lda sprite_pl_splat,y
                sta (L0072),y
                dey
                bpl L177A
                rts

;-------------------------------------------------------------------------

top_right_cell=$5800+39*8
                
entry_slide_off:
                lda #<top_right_cell
                sta player_addr
                lda #>top_right_cell
                sta player_addr+1
                lda #1
                sta L0072

slide_off_loop:
                lda #19
                jsr osbyte

                lda #13
                sta $fe00
                lda L0072
                sta $fe01
                
                lda player_addr
                clc
                adc #8
                sta player_addr
                bcc +
                inc player_addr+1
+
                lda player_addr
                pha
                lda player_addr+1
                pha
; clear portion of screen just scrolled off
                ldx #32

fill_rows_loop:
                ldy #7
                lda #0

fill_row_loop:
                sta (player_addr),y
                dey
                bpl fill_row_loop
                lda player_addr
                clc
                adc #$40
                sta player_addr
                lda player_addr+1
                adc #1
                sta player_addr+1
                dex
                bne fill_rows_loop
                pla
                sta player_addr+1
                pla
                sta player_addr
                inc L0072
                lda L0072
                cmp #41
                bne slide_off_loop
                rts

;-------------------------------------------------------------------------
;
; Entry: X = key to test
; Exit: Z=0 if key pressed (BNE if pressed, BEQ if not pressed)
test_key:
                lda #$81
                ldy #$ff
                jsr osbyte
                tya
                rts
                
;-------------------------------------------------------------------------
                .if editor
;-------------------------------------------------------------------------

ed_keys=[key_z,key_x,key_slash,key_colon,key_return,key_delete,key_tab,key_r,key_s,key_escape,key_left,key_right,key_up,key_down,key_c,key_g]

ed_key_index: .function k
                .for _i:=0,_i<len(ed_keys),_i+=1
                .breakif ed_keys[_i]==k
                .endfor
                .cerror _i==len(ed_keys),'key not found'
                .endfunction _i

; These values are set by RORs, so they can't be rearranged without
; rejigging the routine that sets them.
ed_key_flag_newly_down=$80
ed_key_flag_down=$40
ed_key_flag_rept_4=$20
ed_key_flag_rept_8=$10

ed_file_name_buffer=$700        ; quite safe when in the editor
                
                .section ed_zp
ed_read_addr: .fill 2
ed_level_addr: .fill 2
ed_write_addr: .fill 2
ed_print_addr: .fill 2
ed_brk_addr: .fill 2
ed_box_mode: .fill 1            ;PLOT mode
ed_box_x0: .fill 2
ed_box_y0: .fill 2
ed_box_x1: .fill 2
ed_box_y1: .fill 2
ed_cx: .fill 1
ed_cy: .fill 1
ed_new_otype: .fill 1
ed_cur_ltype: .fill 1
ed_cur_otype: .fill 1
ed_cur_ovalue: .fill 1
; The test start position is valid when bit 7 of ed_test_pl_start_x is
; clear. Otherwise, it hasn't been set, and the level's position
; should be used.
ed_test_pl_start_x: .fill 1
ed_test_pl_start_y: .fill 1
ed_random_frac_table_index: .fill 1
ed_random_ghost_addr_table_index: .fill 1
                .endsection

                .section ed_basic_friendly_zp
ed_mul_a: .fill 1
ed_mul_b: .fill 1
ed_mul_tempb: .fill 1
ed_mul_tempw: .fill 2
ed_mul_result: .fill 2
                .endsection
                
ed_levels_header_magic:
                .dword levels_header_magic

ed_old_language_rom:
                .byte 0

ed_post_brk_loop:
                .cerror (*&$ff)==$ff,'oh no'
                .word 0
ed_key_counters:
                .fill len(ed_keys),0
ed_key_flags:
                .fill len(ed_keys),0
ed_any_keys_pressed:
                .byte 0
ed_shift_pressed:
                .byte 0
ed_ctrl_pressed:
                .byte 0
ed_new_ovalues:
                .fill len(otypes),8

;-------------------------------------------------------------------------

ed_entry:
                jsr ed_one_time_init
                jmp ed_main_loop

ed_main_loop: .proc
                ldx #$ff
                txs

                lda #$7e        ;acknowledge Escape (D.2-37)
                jsr osbyte

                jsr ed_disable_escape
                
                lda #<ed_main_loop
                sta ed_post_brk_loop+0
                lda #>ed_main_loop
                sta ed_post_brk_loop+1
                
                jmp ed_main_menu

                jmp ed_shutdown
                
                .endproc

;-------------------------------------------------------------------------

ed_shutdown: .proc
                lda #$8e        ;enter language ROM (D.2-44)
                ldx ed_old_language_rom
                jmp osbyte
                .endproc

;-------------------------------------------------------------------------

ed_clear_keyboard_buffer: .proc
                lda #15
                ldx #1
                jmp osbyte
                .endproc
                
;-------------------------------------------------------------------------
;
; entry: (ed_level_addr) = level data
ed_print_level_name: .proc
                ldy #LevelData.name
loop:
                lda (ed_level_addr),y
                bmi done
                cmp #32
                bcc done
                jsr oswrch
                iny
                cpy #LevelData.name+17
                bne loop
done:
                rts
                .endproc                
                
;-------------------------------------------------------------------------

ed_main_menu: .proc
                jsr ed_print

                .text 22,7
                .text 129,157,131,141,10,13,129,157,131,141
                .text 31,12,0,"GHOULS: ARCHITECT"
                .text 31,12,1,"GHOULS: ARCHITECT"
                .text 31,0,3
                .byte 0

                lda ed_brk_addr+0
                ora ed_brk_addr+1
                beq brk_checked

                jsr ed_print
                .text 129,'Last error:',135
                .byte 0
                
                jsr ed_print_brk_message
                jsr osnewl
                jsr osnewl
brk_checked:
                
                ldy #0
levels_loop:
                tya
                pha

                jsr ed_prepare_for_level_access

                clc
                tya
                adc #'1'
                sta edit_number_insert_1
                sta edit_number_insert_2

                jsr ed_print
                .byte 133
edit_number_insert_1:
                .text 'X'
                .text ':',131,'Edit level '
edit_number_insert_2:
                .text 'X'
                .text ' -',134
                .byte 0

                jsr ed_print_level_name

                jsr osnewl

                pla
                tay
                iny
                cpy #4
                bne levels_loop

                jsr ed_print

                .text 133,'N:',131,'Set level name',10,13
                .text 133,'R:',131,'Reset level',10,13
                .text 133,'L:',131,'Load levels',10,13
                .text 133,'I:',131,'Import level',10,13
                .text 133,'S:',131,'Save levels',10,13
                .text 133,'E:',131,'Export screen shots',10,13
                .text 133,'*:',131,'* prompt',10,13
                .byte 0

input_loop:
                jsr ed_clear_keyboard_buffer
                
                jsr osrdch

                cmp #'a'
                bcc not_lower
                cmp #'z'+1
                bcs not_lower
                and #$df
not_lower:
                cmp #'L'
                beq load_levels

                cmp #'S'
                beq save_levels

                cmp #'I'
                beq import_level

                cmp #'N'
                beq name_levels

                cmp #'R'
                beq reset_level

                cmp #'E'
                beq export_screen_shots

                cmp #'*'
                beq ed_oscli_prompt

                jsr is_ascii_level_number
                bcs edit_level

                jmp input_loop

; escaped:
;                 .text 0,17,'Escape',0

select_level:
                jsr ed_print
                .text 131,'Select level (1-4):',135
                .byte 0
select_level_loop:
                jsr osrdch
                cmp #27
                beq ed_main_menu
                jsr is_ascii_level_number
                bcc select_level_loop
                jsr oswrch
                pha
                jsr osnewl
                pla
                sec
                sbc #'1'
                jsr ed_prepare_for_level_access
                rts

reset_level: .proc
                jsr select_level

                ; Reset map data
                ldy #level_height-1
y_loop:
                ldx #level_width-1
x_loop:
                lda #0
                jsr ed_write_level
                dex
                bpl x_loop
                dey
                bpl y_loop

                ; Put blocks on the bottom row
                ldx #level_width-1
                ldy #level_height-1
                lda #type_block.index
-
                jsr ed_write_level
                dex
                bpl -

                ; Clear header
                ldy #0
                ldx #LevelData.map
                lda #0
-
                sta (ed_level_addr),y
                iny
                dex
                bne -

                ; Reset name
                ldy #LevelData.name
                ldx #size(LevelData.name)
                lda #13
-
                sta (ed_level_addr),y
                iny
                dex
                bne -

                ; Other stuff
                lda #1
                ldy #LevelData.pl_start_x
                sta (ed_level_addr),y

                lda #23
                ldy #LevelData.pl_start_y
                sta (ed_level_addr),y

                lda #7
                ldy #LevelData.colour3
                sta (ed_level_addr),y

                jmp ed_main_menu

                .endproc
                
name_levels:
                jsr select_level
                
                jsr ed_print
                .text 131,'Enter name:',132,157,135
                .fill 16+2,' '
                .text 156
                .fill 16+3,8
                .byte 0

;                 ldy #LevelData.name
;                 ldx #17
;                 lda #13
; -
;                 sta (ed_level_addr),y
;                 iny
;                 dex
;                 bne -
                
                clc
                lda ed_level_addr+0
                adc #LevelData.name
                sta name_level_block+0
                lda ed_level_addr+1
                adc #0
                sta name_level_block+1

                ldx #<name_level_block
                ldy #>name_level_block
                lda #0
                jsr osword
                bcs ed_main_menu ; taken if ESCAPE pressed

                lda #size(LevelData.name)
                tya
                clc
                adc #LevelData.name
                tay
                lda #13
-
                sta (ed_level_addr),y
                iny
                cpy #LevelData.name+size(LevelData.name)
                bne -
                
                jmp ed_main_menu

name_level_block:
                .word 0
                .byte size(LevelData.name)-1 ;max length (excl CR)
                .byte 32        ;min char
                .byte 126       ;max char
                
edit_level:
                sec
                sbc #'1'
                jsr ed_prepare_for_level_access
                
                lda #0
                sta ed_cx
                sta ed_cy

                ; Invalidate test start pos.
                sec
                ror ed_test_pl_start_x

                jmp ed_editor

is_ascii_level_number:
                cmp #'1'
                bcc not_level_number
                cmp #'4'+1
                bcs not_level_number
                sec
                rts
not_level_number:
                clc
                rts

import_level: .proc
                jsr ed_print
                .text 131,'Import level',10,13
                .byte 0

                jsr enter_file_name

                ldx #<import_levels_org
                ldy #>import_levels_org
                jsr init_levels_file_osfile_block

                ; load file to address given in control block
                lda #$00
                sta levels_file_osfile_block.exec+0

                lda #$ff
                jsr levels_file_osfile

                ldy #0
list_importable_levels_loop:
                tya
                pha             ; save level index

                jsr prepare_for_import_level_access

                tya

                clc
                adc #'1'
                sta import_number_insert_1
                sta import_number_insert_2
                jsr ed_print

                .byte 133
import_number_insert_1:
                .text 'X'
                .text ':',131,'Import level '
import_number_insert_2:
                .text 'X'
                .text ' -',134
                .byte 0

                jsr ed_print_level_name

                jsr osnewl

                pla             ; restore level index
                tay
                iny
                cpy #4
                bne list_importable_levels_loop

import_input_loop:
                jsr ed_clear_keyboard_buffer

                jsr osrdch
                bcs ed_main_loop

                jsr is_ascii_level_number
                bcc import_input_loop

                sta import_number_insert_3

                sec
                sbc #'1'
                sta import_level_index
                jsr prepare_for_import_level_access

                jsr ed_print

                .byte 131
                .text 'Importing level '
import_number_insert_3:
                .text 'X'
                .text ' -',134
                .byte 0

                jsr ed_print_level_name

                jsr osnewl

                ldy #0
list_replaceable_levels_loop:
                tya
                pha

                jsr ed_prepare_for_level_access

                tya

                clc
                adc #'1'
                sta replace_number_insert_1
                sta replace_number_insert_2
                jsr ed_print

                .byte 133
replace_number_insert_1:
                .text 'X'
                .text ':',131,'Replace level '
replace_number_insert_2:
                .text 'X'
                .text ' -',134
                .byte 0

                jsr ed_print_level_name
                jsr osnewl

                pla             ; restore level index
                tay
                iny
                cpy #4
                bne list_replaceable_levels_loop

replace_input_loop:
                jsr ed_clear_keyboard_buffer
                jsr osrdch
                bcs ed_main_loop

                jsr is_ascii_level_number
                bcc replace_input_loop

                sec
                sbc #'1'
                jsr ed_prepare_for_level_access

                lda ed_level_addr+0
                sta import_dest_addr+0
                lda ed_level_addr+1
                sta import_dest_addr+1

                lda import_level_index
                jsr prepare_for_import_level_access

                lda #<size(LevelData)
                sta import_counter+0
                lda #>size(LevelData)
                sta import_counter+1

replace_loop:
                ldy #0
                lda (ed_level_addr),y
import_dest_addr=*+1
                sta $ffff

                inc ed_level_addr+0
                bne +
                inc ed_level_addr+1
+

                inc import_dest_addr+0
                bne +
                inc import_dest_addr+1
+

                sec
                lda import_counter+0
                sbc #1
                sta import_counter+0
                bcs +
                dec import_counter+1
+

                ora import_counter+1
                bne replace_loop

                jmp ed_main_loop

prepare_for_import_level_access:
                jsr ed_prepare_for_level_access

                ; Sneakily switch to the import level data
                .cerror import_levels_org<levels_org

                clc
                lda ed_level_addr+0
                adc #<(import_levels_org-levels_org)
                sta ed_level_addr+0
                lda ed_level_addr+1
                adc #>(import_levels_org-levels_org)
                sta ed_level_addr+1

                rts

import_level_index:
                .byte 0
import_counter:
                .word 0

                .endproc
                
load_levels:
                jsr ed_print
                .text 131,'Load levels',10,13
                .byte 0

                jsr enter_file_name

                jsr init_levels_file_osfile_block_for_load_or_save

                ; load file to address given in control block
                lda #$00
                sta levels_file_osfile_block.exec+0

                lda #$ff        ;load file
                jsr levels_file_osfile
                jmp ed_main_loop
                
save_levels:
                jsr ed_print
                .text 131,'Save levels',10,13
                .byte 0

                jsr enter_file_name

                jsr init_levels_file_osfile_block_for_load_or_save

                lda #$00        ;save file
                jsr levels_file_osfile
                jmp ed_main_loop

levels_file_osfile:
                ldx #<levels_file_osfile_block
                ldy #>levels_file_osfile_block
                jmp osfile

init_levels_file_osfile_block_for_load_or_save:
                ldx #<levels_org
                ldy #>levels_org
init_levels_file_osfile_block:
                ; I don't trust the OSFILE block not to get modified.
                lda file_name_block+0
                sta levels_file_osfile_block.name+0
                lda file_name_block+1
                sta levels_file_osfile_block.name+1
                
                stx levels_file_osfile_block.load+0
                stx levels_file_osfile_block.exec+0
                stx levels_file_osfile_block.start+0
                
                sty levels_file_osfile_block.load+1
                sty levels_file_osfile_block.exec+1
                sty levels_file_osfile_block.start+1

_levels_end=levels_org+level_data_pages*256
                lda #<_levels_end
                sta levels_file_osfile_block.end+0
                lda #>_levels_end
                sta levels_file_osfile_block.end+1
                
                lda #$ff
                sta levels_file_osfile_block.load+2
                sta levels_file_osfile_block.exec+2
                sta levels_file_osfile_block.start+2
                sta levels_file_osfile_block.end+2
                sta levels_file_osfile_block.load+3
                sta levels_file_osfile_block.exec+3
                sta levels_file_osfile_block.start+3
                sta levels_file_osfile_block.end+3

                rts

enter_file_name:
                jsr ed_print
                .text 131,'Enter file name:',135
                .byte 0

                jsr ed_enable_escape

                ldx #<file_name_block
                ldy #>file_name_block
                lda #0
                jsr osword

                php
                jsr ed_disable_escape
                plp
                
                bcs ed_main_loop
                rts

file_name_block:
                .word ed_file_name_buffer
                .byte 250       ;max length
                .byte 32        ;min char
                .byte 126       ;max char

levels_file_osfile_block: .block
name:
                .word ed_file_name_buffer
load:
                .dword 0
exec:
                .dword 0
start:
                .dword 0
end:
                .dword 0
                .endblock

export_screen_shots: .proc
                jsr ed_print
                .text 131,'Export screen shots',10,13
                .byte 0
                jsr enter_file_name

                ldx #0
find_file_name_end_loop:
                lda ed_file_name_buffer,x
                cmp #13
                beq file_name_end_found
                inx
                jmp find_file_name_end_loop
file_name_end_found:

                stx screen_shot_file_name_length
                lda #13
                sta ed_file_name_buffer+1,x

                lda #0          ; level number
                sta screen_shot_level

one_level:
                lda screen_shot_level
                jsr ed_prepare_for_level_access
                jsr ed_editor.redraw

                ; Crappy hack to clear out the editor HUD.
                jsr ed_print
                .byte 31,0,level_height
                .byte 0

                ldx #(31-level_height)*20-1
                lda #' '
clear_editor_hud_loop:
                jsr oswrch
                dex
                bne clear_editor_hud_loop

                ; Print level name
                jsr ed_print
                .byte 17,1
                .byte 31,0,level_height+1
                .byte 0

                ldy #LevelData.name
print_level_name_loop:
                lda (ed_level_addr),y
                cmp #13
                beq level_name_printed
                jsr oswrch
                iny
                jmp print_level_name_loop
level_name_printed:

                ; Save the colour 3 value somewhere.
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                sta $7fff       ; bit ugly but oh well.

                ldx #size(screen_shot_osfile_block_template)-1
copy_osfile_block_loop:
                lda screen_shot_osfile_block_template,x
                sta screen_shot_osfile_block,x
                dex
                bpl copy_osfile_block_loop

                clc
                lda screen_shot_level
                adc #'0'
                ldx screen_shot_file_name_length
                sta ed_file_name_buffer,x

                ldx #<screen_shot_osfile_block
                ldy #>screen_shot_osfile_block
                lda #$00        ; save file
                jsr osfile

                inc screen_shot_level
                lda screen_shot_level
                cmp #4
                bne one_level

                jmp ed_main_loop

screen_shot_level:
                .byte 0
screen_shot_file_name_length:
                .byte 0

screen_shot_osfile_block: .block
name:
                .word 0
load:
                .dword 0
exec:
                .dword 0
start:
                .dword 0
end:
                .dword 0
                .endblock

screen_shot_osfile_block_template: .block
name:
                .word ed_file_name_buffer
load:
                .dword $ffff5800
exec:
                .dword $ffffffff
start:
                .dword $ffff5800
end:
                .dword $ffff8000
                .endblock
                .endproc
                
                .endproc


;-------------------------------------------------------------------------

ed_enable_escape:
                ldx #0          ;enable escape generation
ed_set_escape_status:
                lda #$e5        ;escape status (D.2-75)
                ldy #0          ;write
                jmp osbyte

ed_disable_escape:
                ldx #1          ;make Escape generate ASCII
                bne ed_set_escape_status
                
;-------------------------------------------------------------------------

ed_oscli_prompt: .proc
                ldx #$ff
                txs

                lda ed_brk_addr+0
                ora ed_brk_addr+1
                beq brk_checked

                jsr ed_print_brk_message
                jsr osnewl
brk_checked:
                jsr ed_enable_escape
                
                lda #<ed_oscli_prompt
                sta ed_post_brk_loop+0
                lda #>ed_oscli_prompt
                sta ed_post_brk_loop+1
                
                lda #'*'
                jsr oswrch

                ldx #<block
                ldy #>block
                lda #0          ;read line from input
                jsr osword
                bcs ed_main_loop

                ldx block+0
                ldy block+1
                jsr oscli

                jmp ed_oscli_prompt

block:
                .word $7b00     ;definitely safe
                .byte 255       ;max length
                .byte 32        ;min char
                .byte 126       ;max char
                .endproc

;-------------------------------------------------------------------------

ed_editor: .proc
                ldx #len(ed_keys)-1
                lda #0
-
                sta ed_key_counters,x
                dex
                bpl -

                lda #$ff
                sta ed_cur_ltype

                jsr ed_coff

                jsr redraw

                ; Wait until no keys pressed.
wait_for_keys_up_loop:
                lda #$7a        ; keyboard scan from $10 (AUG p145)
                jsr osbyte
                cpx #$ff
                bne wait_for_keys_up_loop
                
                jsr draw_new_otype
edit_loop:
                lda #19
                jsr osbyte
                
                jsr ed_con
                
                ldx ed_cx
                ldy ed_cy
                jsr ed_gotoxy

                jsr ed_scan_keys

                lda ed_any_keys_pressed
                beq update_stuff

                ldy #len(key_actions)-1
keys_loop:
                ldx key_indexes,y
                lda ed_key_flags,x
                and key_masks,y
                beq next_key

                lda key_routines_lo,y
                sta jsr_key_routine+1
                lda key_routines_hi,y
                sta jsr_key_routine+2
                tya
                pha
jsr_key_routine: jsr $ffff
                pla
                tay
next_key:
                dey
                bpl keys_loop
                jmp edit_loop

update_stuff: .proc
                ldx ed_cx
                ldy ed_cy
                jsr ed_read_level
                cmp ed_cur_ltype
                beq edit_loop

                sta ed_cur_ltype

                jsr ed_coff

                ldx #5
                ldy #29
                lda ed_cur_otype
                jsr ed_erase_otype

                lda ed_cur_ltype
                jsr ed_find_otype

                stx ed_cur_otype
                sta ed_cur_ovalue
                
                ldx #5
                ldy #29
                lda ed_cur_otype
                jsr ed_draw_otype

                ldx #14
                ldy #29
                jsr ed_gotoxy

                ldx ed_cur_otype
                jsr get_num_ovalues
                bne +
                jsr no_ovalue
                jmp edit_loop
+
                lda ed_cur_ovalue
                jsr ed_print_dec
                jmp edit_loop
                .endproc


; entry conditions for routine:
;
; X = index of key in ed_key_flags
;
key_action: .function k,mask,routine
                .endfunction {.key_index:ed_key_index(k),.mask:mask,.routine:routine}

_:=[]
_..=[key_action(key_z,ed_key_flag_rept_4,move_left)]
_..=[key_action(key_x,ed_key_flag_rept_4,move_right)]
_..=[key_action(key_slash,ed_key_flag_rept_4,move_down)]
_..=[key_action(key_colon,ed_key_flag_rept_4,move_up)]
_..=[key_action(key_escape,ed_key_flag_newly_down,ed_main_loop)]
_..=[key_action(key_r,ed_key_flag_newly_down,redraw)]
_..=[key_action(key_s,ed_key_flag_newly_down,set_start_pos)]
_..=[key_action(key_left,ed_key_flag_rept_8,prev_otype)]
_..=[key_action(key_right,ed_key_flag_rept_8,next_otype)]
_..=[key_action(key_up,ed_key_flag_rept_4,next_ovalue)]
_..=[key_action(key_down,ed_key_flag_rept_4,prev_ovalue)]
_..=[key_action(key_return,ed_key_flag_down,add_object)]
_..=[key_action(key_delete,ed_key_flag_down,erase_object)]
_..=[key_action(key_tab,ed_key_flag_newly_down,test_level)]
_..=[key_action(key_c,ed_key_flag_newly_down,next_colour)]
_..=[key_action(key_g,ed_key_flag_newly_down,set_ghost_rect)]
key_actions=_

key_indexes: .byte key_actions.key_index
key_masks: .byte key_actions.mask
key_routines_lo: .byte <key_actions.routine
key_routines_hi: .byte >key_actions.routine

set_ghost_rect: .proc
                bit ed_ctrl_pressed
                bmi unset
                
                ldy #LevelData.flags
                lda (ed_level_addr),y
                and #LevelData.flags.has_ghost_rect
                beq init

                bit ed_shift_pressed
                bmi max

                jsr set_min
done:
                ldy #LevelData.flags
                lda (ed_level_addr),y
                and #LevelData.flags.has_ghost_rect
                beq y_done
                
                ldy #LevelData.ghost_min_x
                lda (ed_level_addr),y
                ldy #LevelData.ghost_max_x
                cmp (ed_level_addr),y
                bcc x_done            ; taken if min<max
                pha             ; save greater
                lda (ed_level_addr),y ; A = lesser
                tax             ; X = lesser
                pla             ; restore greater
                sta (ed_level_addr),y ; max = greater
                txa                   ; A = lesser
                ldy #LevelData.ghost_min_x
                sta (ed_level_addr),y ; min = lesser
x_done:
                ldy #LevelData.ghost_min_y
                lda (ed_level_addr),y
                ldy #LevelData.ghost_max_y
                cmp (ed_level_addr),y
                bcc y_done            ; taken if min<max
                pha             ; save greater
                lda (ed_level_addr),y ; A = lesser
                tax             ; X = lesser
                pla             ; restore greater
                sta (ed_level_addr),y ; max = greater
                txa                   ; A = lesser
                ldy #LevelData.ghost_min_y
                sta (ed_level_addr),y ; min = lesser
y_done:
                jsr redraw
                rts

unset:
                ldy #LevelData.flags
                lda (ed_level_addr),y
                and #(~LevelData.flags.has_ghost_rect)&$ff
                sta (ed_level_addr),y
                jmp done

max:
                jsr set_max
                jmp done

init:
                lda (ed_level_addr),y
                ora #LevelData.flags.has_ghost_rect
                sta (ed_level_addr),y

                jsr set_min
                jsr set_max
                jmp done

set_min:
                lda ed_cx
                ldy #LevelData.ghost_min_x
                sta (ed_level_addr),y

                jsr get_ghost_rect_y
                ldy #LevelData.ghost_min_y
                sta (ed_level_addr),y

                rts

set_max:
                lda ed_cx
                ldy #LevelData.ghost_max_x
                sta (ed_level_addr),y

                jsr get_ghost_rect_y
                ldy #LevelData.ghost_max_y
                sta (ed_level_addr),y

                rts

get_ghost_rect_y:
                ; don't allow the ghost to be placed on the bottom row
                lda ed_cy
                cmp #level_height-1
                bcc +
                lda #level_height-2
+
                rts

                .endproc
                
                
next_colour:
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                and #15
                clc
                adc #1

                ; The last 4 flashing colours are pointless, since
                ; they're not obviously different from the first 4...
                cmp #12
                bcc +
                lda #0
+
                sta (ed_level_addr),y
                jmp redraw

test_level:
                jsr ed_coff
                jsr ed_test
                jmp ed_editor
                
erase_object:
                lda #0
                jmp add_object.place_ltype
                
add_object: .proc
                ldy ed_new_otype
                lda otypes_ed_flags,y
                and #ed_flags_repeat
                bne add

                lda ed_key_flags,x
                and #ed_key_flag_newly_down
                beq done
                
add:
                ldx ed_new_otype
                lda ed_new_ovalues,y
                jsr ed_pack_ltype
                
place_ltype:
                ldx ed_cx
                ldy ed_cy
                jsr ed_place_ltype

done:
                rts
                .endproc
                
get_num_ovalues:
                sec
                lda otypes_ltype_end,x
                sbc otypes_ltype_begin,x
                ; C=1
                sbc #1
                rts
                
next_ovalue: .proc
                jsr ed_coff
                ldx ed_new_otype
                jsr get_num_ovalues
                beq done
                cmp ed_new_ovalues,x
                beq wrap
                inc ed_new_ovalues,x
print:
                jsr print_new_ovalue
done:
                rts
wrap:
                lda #0
                sta ed_new_ovalues,x
                beq print
                .endproc

prev_ovalue: .proc
                jsr ed_coff
                ldx ed_new_otype
                jsr get_num_ovalues
                beq done
                dec ed_new_ovalues,x
                bpl print
                sta ed_new_ovalues,x
print:
                jsr print_new_ovalue
done:
                rts
                .endproc

prev_otype:
                jsr ed_coff
                jsr erase_new_otype
                ldx ed_new_otype
                dex
                bpl +
                ldx #len(otypes)-1
+
                stx ed_new_otype
                jsr draw_new_otype
                rts
                
next_otype:
                jsr ed_coff
                jsr erase_new_otype
                ldx ed_new_otype
                inx
                cpx #len(otypes)
                bcc +
                ldx #0
+
                stx ed_new_otype
                jsr draw_new_otype
                rts

erase_new_otype:
                ldx #5
                ldy #27
                lda ed_new_otype
                jmp ed_erase_otype
                
draw_new_otype:
                ldx #5
                ldy #27
                lda ed_new_otype
                jsr ed_draw_otype

print_new_ovalue:
                ldx #14
                ldy #27
                jsr ed_gotoxy

                ldx ed_new_otype
                jsr get_num_ovalues
                beq no_ovalue
                lda ed_new_ovalues,x
                jmp ed_print_dec

no_ovalue:
                jsr ed_print
                .text '--'
                .byte 0
                rts
                
set_start_pos:
                bit ed_shift_pressed
                bmi set_level_start_pos ; taken if SHIFT pressed

                ; Set test start pos. Or clear it if it's the same.
                lda ed_cx
                cmp ed_test_pl_start_x
                bne set_test_start_pos
                lda ed_cy
                cmp ed_test_pl_start_y
                bne set_test_start_pos

                ; Invalidate test start pos.
                sec
                ror ed_test_pl_start_x
                jmp redraw

set_test_start_pos:
                lda ed_cx
                sta ed_test_pl_start_x
                lda ed_cy
                sta ed_test_pl_start_y
                jmp redraw

set_level_start_pos:
                lda ed_cx
                ldy #LevelData.pl_start_x
                sta (ed_level_addr),y

                lda ed_cy
                ldy #LevelData.pl_start_y
                sta (ed_level_addr),y

                ; fall through

redraw:
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                sta colour3_physical_colour
                
                jsr ed_print
                .text 22,5
                .byte 0

                jsr ed_coff

                jsr ed_print
                .byte 19,3
colour3_physical_colour:
                .byte 7
                .byte 0,0,0

                .byte 17,2
                .text 31,0,27,'NEW:'
                .text 31,8,27,'CVAL:'
                .text 31,0,29,'CUR:'
                .text 31,8,29,'CVAL:'
                .text 31,0,31
                .byte 0

                lda level_finished
                beq died
                jsr ed_print
                .text 'WON: Y',0
                jmp draw_level
died:
                jsr ed_print
                .text 'WON: ',17,1,'N',17,2
                .byte 0
                
draw_level:
                jsr ed_draw_level

                ldy #1
                jsr ed_gcol0

                lda #0
                sta ed_box_x0
                sta ed_box_y0
                lda #19
                sta ed_box_x1
                lda #25
                sta ed_box_y1
                lda #5
                jsr ed_box

                ldy #LevelData.flags
                lda (ed_level_addr),y
                and #LevelData.flags.has_ghost_rect
                beq ghost_rect_done ; taken if ghost rect not set

                ldy #LevelData.ghost_min_x
                lda (ed_level_addr),y
                sta ed_box_x0

                ldy #LevelData.ghost_min_y
                lda (ed_level_addr),y
                sta ed_box_y0

                ldy #LevelData.ghost_max_x
                lda (ed_level_addr),y
                sta ed_box_x1

                ldy #LevelData.ghost_max_y
                lda (ed_level_addr),y
                sta ed_box_y1

                lda #24+5       ; dotted line
                jsr ed_box
ghost_rect_done:
                
                rts
                
move_left:
                ldx ed_cx
                beq +
                dex
+
                stx ed_cx
                rts

move_right:
                ldx ed_cx
                cpx #level_width-1
                bcs +
                inx
+
                stx ed_cx
                rts

move_up:
                ldx ed_cy
                beq +
                dex
+
                stx ed_cy
                rts

move_down:
                ldx ed_cy
                cpx #level_height-1
                bcs +
                inx
+
                stx ed_cy
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Split ltype into otype and create parameter.
; 
; Entry: A=ltype
; Exit: X=otype
;       A=create parameter
; Preserves: Y
ed_find_otype: .proc
                ldx #len(otypes)-1
loop:
                cmp otypes_ltype_end,x
                bcs next
                cmp otypes_ltype_begin,x
                bcc next
                
                sbc otypes_ltype_begin,x
                rts

next:
                dex
                bpl loop

                ; Assume it was the blank entry...
                inx             ;X=0
                txa             ;A=0
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Pack otype and create parameter into ltype.
; 
; Entry: X=otype
;        A=create parameter
; Exit: A=ltype
ed_pack_ltype: .proc
                clc
                adc otypes_ltype_begin,x

                ; Clamp. Be vaguely resilient.
                cmp otypes_ltype_begin,x
                bcc min

                cmp otypes_ltype_end,x
                bcc done

                lda otypes_ltype_end,x
                sbc #1          ; the range is inclusive/exclusive
done:
                rts

min:
                lda otypes_ltype_begin,x
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Get player start pos.
;
; Entry: ed_level_addr = address of level
; Exit: X = player start X (0-19)
;       Y = player start Y (0-25)
ed_get_pl_start: .proc
                ldy #LevelData.pl_start_x
                lda (ed_level_addr),y
                tax

                ldy #LevelData.pl_start_y
                lda (ed_level_addr),y
                tay
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Get number of possible create parameters for the given otype. Valid
; create parameters start at 0.
; 
; Entry: A = otype
; Return: A = number of valid create parameters
ed_get_num_otype_create_parameters: .proc
                tax
                cpx #len(otypes)
                bcs none

                sec
                lda otypes_ltype_end,x
                sbc otypes_ltype_begin,x
                rts

none:
                lda #0
                rts
                .endproc

;-------------------------------------------------------------------------

ed_convert_to_game_coordinates:
                iny
                iny
                iny
                iny
                rts                
                
;-------------------------------------------------------------------------
;
; Test current level.
;
; Entry: ed_level_addr = address of level
ed_test: .proc
                jsr reset_envelopes
                
                lda ed_level_addr+0
                sta level_draw_ptr+0
                lda ed_level_addr+1
                sta level_draw_ptr+1
                
                lda #12
                jsr oswrch

                ; Set up player start pos.
                ;
                ; If testing with SHIFT+TAB, always use level start
                ; pos. If testing with TAB, use test start pos if
                ; available, and level start pos if not.
                bit ed_shift_pressed
                bmi use_level_start ; taken if shift pressed

                bit ed_test_pl_start_x
                bmi use_level_start ; taken if test start not set

                ldx ed_test_pl_start_x
                ldy ed_test_pl_start_y
                jmp got_start_pos

use_level_start:
                jsr ed_get_pl_start
got_start_pos:
                ; Adjust for editor vs game positioning.
                jsr ed_convert_to_game_coordinates
                jsr ed_get_screen_write_addr
                
                lda ed_write_addr+0
                sta player_addr+0
                lda ed_write_addr+1
                sta player_addr+1

                ; Reset ghosts table
                ldx #7
-
                lda #0
                sta ghosts_table,x
                dex
                bpl -
                
                ldy #LevelData.flags
                lda (ed_level_addr),y
                and #LevelData.flags.has_ghost_rect
                beq init_default_random_ghost

                ; Pick position in ghost rect

                ldy #LevelData.ghost_max_x
                lda (ed_level_addr),y
                ldy #LevelData.ghost_min_x
                sec
                sbc (ed_level_addr),y ; ghost rect width
                jsr mul_random_frac   ; A = ghost X offset
                clc
                adc (ed_level_addr),y ; A = ghost X
                pha             ; save ghost X

                ldy #LevelData.ghost_max_y
                lda (ed_level_addr),y
                ldy #LevelData.ghost_min_y
                sec
                sbc (ed_level_addr),y ; ghost rect_height
                jsr mul_random_frac   ; A = ghost Y offset
                clc
                adc (ed_level_addr),y ; A = ghost Y
                tay             ; Y = ghost Y
                pla             ; restore ghost X
                tax             ; X = ghost X
                
                ; lda (ed_level_addr),y
                ; sec
                ; tax
                ; ldy #LevelData.ghost_min_y
                ; lda (ed_level_addr),y
                ; tay
                jsr ed_convert_to_game_coordinates
                ; dey             ; ??? - not sure why necessary
                jsr ed_get_screen_write_addr

                lda ed_write_addr+0
                sta ghosts_table+0
                lda ed_write_addr+1
                sta ghosts_table+1
                jmp init_level

mul_random_frac: .proc
                sta ed_mul_a
                ; get random 1.7 fixed point fraction - min $00 (0.0),
                ; max $80 (1.0)
                ldx ed_random_frac_table_index
                lda ed_random_frac_table,x
                inx
                cpx #size(ed_random_frac_table)
                bcc +
                ldx #0
+
                stx ed_random_frac_table_index
                sta ed_mul_b
                jsr ed_mul_8x8_16
                lda ed_mul_result+0
                ldx #7
-
                lsr ed_mul_result+1
                ror a
                dex
                bne -
                rts
                .endproc

init_default_random_ghost:
                ldx ed_random_ghost_addr_table_index
                inc ed_random_ghost_addr_table_index
                inc ed_random_ghost_addr_table_index ; it's a 2-byte
                                                     ; table
                lda ed_random_ghost_addr_table+0,x
                sta ghosts_table+0
                lda ed_random_ghost_addr_table+1,x
                sta ghosts_table+1
                ; fall through to init_level
                
init_level:
                ldx #0
                jsr entry_init_level

                jsr copy_data_behind_player

                ; lda #15
                ; ldx #1
                ; jsr osbyte
                ; lda #7
                ; jsr oswrch
                ; jsr osrdch
                
                ; ; ???
                ; lda #0
                ; sta L0084

                ; Initial bonus and score
                ldx #4
-
                lda initial_score,x
                sta score_chars,x
                dex
                bpl -

                lda initial_bonus+0
                sta bonus_chars+0
                lda initial_bonus+1
                sta bonus_chars+1

                ; Copy level name

                lda #<1279
                sta level_name_x+0
                lda #>1279
                sta level_name_x+1
                
                ldy #LevelData.name
                ldx #0
name_len_loop:
                lda (ed_level_addr),y
                sta level_name,x
                cmp #13
                beq next_dest_char

                sec
                lda level_name_x+0
                sbc #64
                sta level_name_x+0
                bcs next_src_char
                dec level_name_x+1
next_src_char:
                iny
next_dest_char:
                inx
                cpx #size(LevelData.name)
                bne name_len_loop

                jsr ed_print

                ; GCOL 0,1
                .byte 18,0,1

                ; VDU 5
                .byte 5

                ; MOVE ???,1023-30*32
                .byte 25,4
level_name_x:
                .word 0
                .word 28

                ; Space for level name. Any embedded CRs are copied
                ; too... VDU 5, so whatever.
level_name:
                .fill size(LevelData.name),'x'

                ; VDU 4
                .byte 4

                ; MOVE 0,60
                .byte 25,4
                .word 0,60

                ; DRAW 0,952
                .byte 25,5
                .word 0,952

                ; MOVE 1279,60
                .byte 25,4
                .word 1279,60

                ; DRAW 1279,952
                .byte 25,5
                .word 1279,952

                ; MOVE 1080,800
                .byte 25,4
                .word 1080,800
                
                ; DRAW 1080,860
                .byte 25,5
                .word 1080,860
                
                ; GCOL 0,2
                .byte 18,0,2
                
                ; MOVE 0,952
                .byte 25,4
                .word 0,952
                
                ; PLOT 21,1279,952
                .byte 25,21
                .word 1279,952
                
                ; MOVE 1092,864
                .byte 25,4
                .word 1092,864
                
                ; DRAW 1270,864
                .byte 25,5
                .word 1270,864

                ; COLOUR 1
                .byte 17,1

                ; PRINT TAB(14,1)
                .byte 31,14,1

                ; "BONUS"
                .byte 240,241,242

                ; COLOUR 2
                .byte 17,2

                ; PRINT TAB(0,1)
                .byte 31,0,1

                ; Default score
initial_score:
                .byte 230,230,230,230,230

                ; PRINT TAB(18,1)
                .byte 31,18,1

                ; Default bonus chars
initial_bonus:
                .byte 235,230

                .byte 0

                ; VDU 4 switches the cursor back on.
                jsr ed_coff
                
                jsr entry_game_2

                ; Flush all buffers.
                lda #15         ; flush buffers
                ldx #0
                jsr osbyte
                rts
                
entry_game_2:
                jsr entry_game
                rts

                .endproc
                
;-------------------------------------------------------------------------
;
; Draw current level.
;
; Entry: ed_level_addr = current level
ed_draw_level: .proc

                lda #19
                jsr oswrch
                lda #3
                jsr oswrch
                ldy #LevelData.colour3
                lda (ed_level_addr),y
                jsr oswrch
                lda #0
                jsr oswrch
                jsr oswrch
                jsr oswrch

                lda #0
                sta yc
y_loop:
                lda #0
                sta xc
x_loop:
                ldx xc
                ldy yc
                jsr ed_read_level
                
                ldx xc
                ldy yc
                jsr ed_draw_ltype

                inc xc
                lda xc
                cmp #level_width
                bne x_loop

                inc yc
                lda yc
                cmp #level_height
                bne y_loop

                jsr ed_get_pl_start
                lda #$f0
                jsr draw_pl_start

                ldx ed_test_pl_start_x
                bmi done        ; taken if test start pos invalid
                ldy ed_test_pl_start_y
                lda #$0f
                jsr draw_pl_start

done:
                rts

draw_pl_start:
                sta pl_start_colour
                jsr ed_get_screen_write_addr

                ldx #15
                jsr draw_pl_start_half

                jsr ed_next_write_addr_screen_row

                ldx #31
draw_pl_start_half:
                ldy #15
-
                lda #$00
                sta value
                lda #$11
                sta mask
                jsr pixel
                jsr pixel
                jsr pixel
                jsr pixel
                sta (ed_write_addr),y
                dex
                dey
                bpl -
                rts

pixel:
                lda sprite_pl_facing,x
                and mask
                beq +
                lda pl_start_colour
                and mask
+
                ora value
                sta value
                asl mask
                rts

xc: .byte 0
yc: .byte 0
pl_start_colour: .byte 0
mask: .byte 0
value: .byte 0
                .endproc

;-------------------------------------------------------------------------

ed_place_ltype: .proc
                pha
                jsr ed_read_level
                jsr ed_erase_ltype
                pla

                pha
                jsr ed_write_level
                pla
                
                ; Assume the old item was 2x2 and the new is 1x1.
                jsr ed_draw_ltype

                inx
                jsr ed_read_level
                bcs done_x1y0   ;taken if (X+1,Y+0) is out of bounds
                jsr ed_draw_ltype
done_x1y0:
                dex

                iny
                jsr ed_read_level
                bcs done_x0y1   ;taken if (X+0,Y+1) is out of bounds
                jsr ed_draw_ltype
done_x0y1:
                
                inx
                jsr ed_read_level
                bcs done_x1y1   ; taken if (X+1,Y+1) is out of bounds
                jsr ed_draw_ltype
done_x1y1:
                
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Draw an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_draw_ltype: .proc
                clc             ;drawing
                jmp ed_draw_or_erase_ltype
                .endproc

;-------------------------------------------------------------------------
;
; Erase an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_erase_ltype: .proc
                sec             ;erasing
                jmp ed_draw_or_erase_ltype
                .endproc

;-------------------------------------------------------------------------
;
; Draw an object, given the otype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_draw_otype: .proc
                clc             ;drawing
                jmp ed_draw_or_erase_otype
                .endproc

;-------------------------------------------------------------------------
;
; Erase an object, given the otype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: X/Y
ed_erase_otype: .proc
                sec             ;erasing
                jmp ed_draw_or_erase_otype
                .endproc
                
;-------------------------------------------------------------------------
;
; Draw or erase an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
;        C = 0 to draw, 1 to erase
; Preserves: X/Y
ed_draw_or_erase_ltype: .proc
                ror ed_draw_or_erase_otype.erasing       ;bit 7 set if erasing
                stx ed_draw_or_erase_otype.xc
                sty ed_draw_or_erase_otype.yc

                jsr ed_find_otype
                jmp ed_draw_or_erase_otype.common
                .endproc

;-------------------------------------------------------------------------
;
; Draw or erase an object, given the ltype.
;
; Entry: A = ltype
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
;        C = 0 to draw, 1 to erase
; Preserves: X/Y
ed_draw_or_erase_otype: .proc
                ror erasing
                stx xc
                sty yc
                
                tax             ;X=otype
common:
                lda otypes_otype_flags,x
                sta otype_flags
                lda otypes_ed_flags,x
                sta ed_flags
                lda otypes_sprite_data_lo,x
                sta ed_read_addr+0
                lda otypes_sprite_data_hi,x
                sta ed_read_addr+1

                jsr row

                lda otype_flags
                and #otype_flags_height2
                beq done        ;taken if height=1

                ; lda yc
                ; cmp #level_height-1
                ; beq done

                inc yc
                jsr row
                dec yc

done:
                ldx xc
                ldy yc
                rts
                
row:
                ldx xc
                ldy yc
                jsr ed_get_screen_write_addr
                
                jsr do_item_part

                lda otype_flags
                and #otype_flags_width2
                beq row_done    ;taken if width=1

                ; lda xc
                ; cmp #level_width-1
                ; beq row_done

do_item_part:
                ldy #15
                lda #0
                bit erasing
                bmi erase_part_loop ;taken if erasing

                ; The blank item doesn't overwrite. 
                lda ed_read_addr+0
                ora ed_read_addr+1
                beq next_column
                
                ldx #0          ;Unmasked mask
                lda ed_flags
                and #ed_flags_masked
                beq +           ;taken if unmasked
                ldx #2          ;Masked mask
+
part_loop:
                lda (ed_read_addr),y
                and masks+0,x
                sta (ed_write_addr),y
                dey

                lda (ed_read_addr),y
                and masks+1,x
                sta (ed_write_addr),y
                dey

                bpl part_loop

next_part:
                lda #16
                ldx #ed_read_addr
                jsr ed_add16z

next_column:
                lda #16
                ldx #ed_write_addr
                jsr ed_add16z

row_done:
                rts
                
erase_part_loop:
                sta (ed_write_addr),y
                dey
                bpl erase_part_loop
                bmi next_part

masks:
                .byte $ff,$ff   ;unmasked
                .byte $ff,$00   ;masked

erasing:
                .byte 0
xc:
                .byte 0
yc:
                .byte 0                
otype_flags:
                .byte 0
ed_flags:
                .byte 0
                .endproc
                
;-------------------------------------------------------------------------
;
; Set ed_write_addr to the screen address for a given X/Y coordinate.
;
; Entry: X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Exit: ed_write_addr = screen address
; Preserves: X/Y
ed_get_screen_write_addr: .proc
                lda #0
                sta ed_write_addr+0

                sty ed_write_addr+1 ;*256

                tya
                lsr a               ;>*128
                ror ed_write_addr+0 ;<*128
                lsr a               ;>*64
                ror ed_write_addr+0 ;<*64 (C=0)
                
                adc ed_write_addr+1
                sta ed_write_addr+1

                txa
                asl a           ;*2 (0-38)
                asl a           ;*4 (0-76)
                asl a           ;*8 (0-152)
                asl a           ;*16 (0-304)
                bcc +
                inc ed_write_addr+1 ;definitely needed
+
                clc
                adc ed_write_addr+0
                sta ed_write_addr+0
                bcc +
                inc ed_write_addr+1
+

                ; The editor screen starts at (0,0).
                clc
                lda ed_write_addr+1
                adc #$58
                sta ed_write_addr+1
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read value from level map.
;
; Entry: ed_level_addr = address of level
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Exit: A = value read from map
; Preserves: X/Y
ed_read_level: .proc
                sty reload_y+1
                jsr ed_prepare_for_level_map_access
                lda (ed_read_addr),y
reload_y: ldy #$ff
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Write value to level map.
;
; Entry: ed_level_addr = address of level
;        A = value to write
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Preserves: A/X/Y
ed_write_level: .proc
                sty reload_y+1
                pha
                jsr ed_prepare_for_level_map_access
                pla
                bcs +
                sta (ed_read_addr),y ;hmm
+
reload_y: ldy #$ff
                rts
                .endproc

;-------------------------------------------------------------------------
; 
; Sets things up so that (ed_read_addr),Y will access the appropriate
; value in the level.
;
; Entry: ed_level_addr = address of level
;        X = X coordinate (0-19)
;        Y = Y coordinate (0-25)
; Exit: ed_read_addr = address
;       Y = offset for address
;       C = 0 if valid coordinates, 1 if invalid coordinates
; Preserves: X
ed_prepare_for_level_map_access: .proc
                cpx #level_width
                bcs done
                cpy #level_height
                bcs done

                lda #0
                sta ed_read_addr+1

                ; Y*16
                tya
                asl a           ;*2 - 0-50
                asl a           ;*4 - 0-100
                asl a           ;*8 - 0-200
                rol ed_read_addr+1
                asl a           ;*16 - 0-400
                rol ed_read_addr+1
                sta ed_read_addr+0

                ; Y*16+Y*4 = Y*20
                tya
                asl a           ;*2
                asl a           ;*4 (C=0)
                adc ed_read_addr+0
                sta ed_read_addr+0
                bcc +
                inc ed_read_addr+1
+

                clc
                lda ed_read_addr+0
                adc ed_level_addr+0
                sta ed_read_addr+0
                lda ed_read_addr+1
                adc ed_level_addr+1
                sta ed_read_addr+1

                ; This is stupid, but it's going to be too confusing
                ; to call from BASIC otherwise.
                txa
                clc
                adc #LevelData.map
                tay
done:
                rts
                .endproc


;-------------------------------------------------------------------------
;
; Set cursor on (con) or off (coff)
;
; Preserves: X
ed_coff:
                lda #10
                bne set_r10
ed_con:
                lda #0
set_r10:
                ldx #10
                stx $fe00
                sta $fe01
                rts

;-------------------------------------------------------------------------
;
; Do a PRINT TAB
;
; Entry: X = X coordinate
;        Y = Y coordinate
; Preserves: X/Y
ed_gotoxy: .proc
                lda #31
                jsr oswrch
                txa
                jsr oswrch
                tya
                jmp oswrch
                .endproc

;-------------------------------------------------------------------------
;
; Do a GCOL 0,y
;
; Entry: Y = colour
; Preserves: X/Y

ed_gcol0: .proc
                lda #18
                jsr oswrch
                lda #0
                jsr oswrch
                tya
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
;
; Draw a box surrounding the specified range of map squares.
;
; The box edges are to the top and left of the top left square, and the
; bottom and right of the bottom right square.
;
; Entry: A = plot mode for the lines, as per PLOT/VDU 25
;        ?ed_box_x0 = X coord of top left square (0-19)
;        ?ed_box_y0 = Y coord of top left square (0-25)
;        ?ed_box_x1 = X coord of bottom right square (0-19)
;        ?ed_box_y1 = Y coord of bottom right square (0-25)

ed_box: .proc
                sta ed_box_mode
                
                ; x0*64
                ldx #ed_box_x0
                ldy #6
                jsr shlzbw

                ; 1023-y0*32
                ldx #ed_box_y0
                ldy #5
                jsr shlzbw
                jsr rsub1023zw

                ; x1*64+63
                ldx #ed_box_x1
                ldy #6
                jsr shlzbw
                lda #63
                jsr ed_add16z

                ; 1023-(y1*32+31)
                ldx #ed_box_y1
                ldy #5
                jsr shlzbw
                lda #31
                jsr ed_add16z
                jsr rsub1023zw

                lda #4
                ldx #ed_box_x0
                ldy #ed_box_y0
                jsr plot

                lda ed_box_mode
                ldx #ed_box_x1
                ldy #ed_box_y0
                jsr plot

                lda ed_box_mode
                ldx #ed_box_x1
                ldy #ed_box_y1
                jsr plot
                
                lda ed_box_mode
                ldx #ed_box_x0
                ldy #ed_box_y1
                jsr plot

                lda ed_box_mode
                ldx #ed_box_x0
                ldy #ed_box_y0
                jsr plot

                rts

plot:
                pha
                lda #25
                jsr oswrch
                pla
                jsr oswrch
                lda 0,x
                jsr oswrch
                lda 1,x
                jsr oswrch
                lda 0,y         ;16 bit address ;(
                jsr oswrch
                lda 1,y         ;16 bit address ;(
                jmp oswrch
                
rsub1023zw:
                sec
                lda #<1023
                sbc 0,x
                sta 0,x
                lda #>1023
                sbc 1,x
                sta 1,x
                rts
                
shlzbw:
                lda #0
                sta 1,x
-
                asl 0,x
                rol 1,x
                dey
                bne -
                rts

                .endproc

;-------------------------------------------------------------------------
;
; Scan editor keys
;
ed_scan_keys: .proc

                lda #0
                sta ed_any_keys_pressed
                
                ldy #len(ed_keys)-1
loop:
                tya
                pha

                ldx table,y
                jsr ed_test_key

                pla
                tay

                lda #0
                bcc store

                lda #$ff
                sta ed_any_keys_pressed

                ldx ed_key_counters,y
                cpx #$80        ;C=1 if bit 7 set
                inx
                txa
                bcc store
                ; keep counting in bits 0-7, but suppress further
                ; occurrences of $00 or $01
                ora #$80

store:
                sta ed_key_counters,y

                ; repeat 8
                pha
                and #7
                jsr if1

                ; repeat 4
                and #3
                jsr if1

                ; down
                pla
                cmp #1
                ror lda_key_flags+1

                ; newly down
                jsr if1

lda_key_flags: lda #$ff
                sta ed_key_flags,y

                dey
                bpl loop

                ldx #inkey(key_shift)
                jsr ed_test_key
                ror ed_shift_pressed

                ldx #inkey(key_ctrl)
                jsr ed_test_key
                ror ed_ctrl_pressed
                
                rts

if1:
                cmp #1
                beq +
                clc
+
                ror lda_key_flags+1
                rts

table:
                .for _i:=0,_i<len(ed_keys),_i+=1
                .byte inkey(ed_keys[_i])
                .endfor
                .endproc

;-------------------------------------------------------------------------
; entry: X = inkey number
; exit: C=1 if pressed

ed_test_key: .proc
                jsr test_key
                cpx #$ff
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Sets up ed_level_addr for access to a specific level.
; 
; Entry: A = level index, 0-3
; Exit: ed_level_addr set up
; Preserves: Y
; 
ed_prepare_for_level_access: .proc
                tax
                
                lda #<(levels_org+4)
                sta ed_level_addr+0
                lda #>(levels_org+4)
                sta ed_level_addr+1

loop:
                txa
                beq done

                clc
                lda ed_level_addr+0
                adc #<size(LevelData)
                sta ed_level_addr+0
                lda ed_level_addr+1
                adc #>size(LevelData)
                sta ed_level_addr+1

                dex
                jmp loop
done:
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Check if if looks like valid level data is loaded.
;
; Exit: C=1 if yes, C=0 if no
; 
ed_check_levels_header_magic: .proc
                ldx #3
loop:
                lda levels_org,x
                cmp ed_levels_header_magic,x
                bne no
                dex
                bpl loop
                rts
no:
                clc
                rts
                .endproc

;-------------------------------------------------------------------------
;
; BRK handler. Stores the BRK address in (ed_brk_addr) and jumps to
; the post-BRK routine.
; 
ed_brk_handler: .proc
                lda $fd
                sta ed_brk_addr+0
                lda $fe
                sta ed_brk_addr+1

                jmp (ed_post_brk_loop)
                .endproc

;-------------------------------------------------------------------------
;
; Print last BRK message and reset the brk message pointer.
;
; Exit: ed_brk_addr?0 = 0
;       ed_brk_addr?1 = 0
; Preserves: X
ed_print_brk_message: .proc
                ldy #1
loop:
                lda (ed_brk_addr),y
                beq done
                jsr oswrch
                iny
                bne loop
done:

                jsr ed_print
                .text 10,13,129,'(Error addr: &',0
                lda ed_brk_addr+1
                jsr ed_print_hex
                lda ed_brk_addr+0
                jsr ed_print_hex
                jsr ed_print
                .text ')',10,13,129,'(Error number: &',0
                ldy #0
                lda (ed_brk_addr),y
                jsr ed_print_hex
                jsr ed_print
                .text ')',10,13,0
                
                lda #0
                sta ed_brk_addr+0
                sta ed_brk_addr+1
                rts
                .endproc
                
;-------------------------------------------------------------------------

ed_one_time_init: .proc
                lda #$fc        ;current language ROM (D.2-83)
                jsr ed_osbyte_x00_yff
                stx ed_old_language_rom

                lda #<ed_brk_handler
                sta brkv+0
                lda #>ed_brk_handler
                sta brkv+1
                
                ldx #ed_zp_begin
                lda #0
-
                sta 0,x
                inx
                cpx #ed_zp_end
                bne -

                lda #$80
                sta ed_test_pl_start_x

                lda $fe44       ; cheap and cheerful
                and #$7f        ; the last entry will never be
                                ; initially selected
                sta ed_random_frac_table_index

                lda $fe44
                and #$fe
                sta ed_random_ghost_addr_table_index

                ldx #<run_gudgs
                ldy #>run_gudgs
                jsr oscli

                jsr ed_check_levels_header_magic
                bcs levels_loaded ;some left in RAM

                ldx #<load_glevels
                ldy #>load_glevels
                jsr oscli

levels_loaded:
                rts

run_gudgs:
                .text '/$.GUDGS',13

load_glevels:
                .text 'LOAD $.GLEVELS',13
                .endproc

;-------------------------------------------------------------------------
;
; Print 0-terminated string following call.
;
; 0 bytes in VDU commands are handled correctly. The terminating 0
; must stand on its own. (This does mean the string can't be
; terminated in the middle of a command sequence.)
; 
ed_print: .proc
                pla
                sta ed_print_addr+0
                pla
                sta ed_print_addr+1

loop:
                ldx #ed_print_addr
                jsr ed_incz

                lda (0,x)
                bne print

                lda #$da
                jsr ed_osbyte_x00_yff
                cpx #0
                beq done

                lda #0
print:
                jsr oswrch
                jmp loop

done:
                lda ed_print_addr+1
                pha
                lda ed_print_addr+0
                pha
                rts

                .endproc

;-------------------------------------------------------------------------
;
; Print 2-digit decimal value using OSWRCH
;
; Entry: A = value to print, 0-99 ($00-$63)
; Preserves: Y
ed_print_dec: .proc
                ldx #'0'
-
                sec
                sbc #10
                bcc +
                inx
                bne -
+
                adc #10
                pha
                txa
                jsr oswrch
                pla
                clc
                adc #'0'
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
; 
; Print hex value using OSWRCH
;
; Entry: A = value to print
; Preserves: X/Y
ed_print_hex: .proc
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr nybble
                pla
                and #$0f
nybble:
                sed
                clc
                adc #$90
                adc #$40
                cld
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
;
; Increment zero page word.
;
; Entry: X = zp address of word
; Preserves: A/X/Y/C
ed_incz: .proc
                inc 0,x
                bne +
                inc 1,x
+
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Add 320 to ed_write_addr, moving the address to the next screen row.
;
; Entry: ed_write_addr = address
; Exit: ed_write_addr = address+320
; Preserves: X/Y
ed_next_write_addr_screen_row: .proc
                clc
                lda ed_write_addr+0
                adc #$40
                sta ed_write_addr+0
                lda ed_write_addr+1
                adc #$01
                sta ed_write_addr+1
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Add an 8-bit value to a 16-bit zero page value.
;
; Entry: A = 8-bit value
;        X = address of 16-bit value
; Preserves: X/Y
ed_add16z: .proc
                clc
                adc 0,x
                sta 0,x
                bcc +
                inc 1,x
+
                rts
                .endproc

;-------------------------------------------------------------------------

ed_osbyte_x00_yff:
                ldx #$00
ed_osbyte_yff:
                ldy #$ff
                jmp osbyte

;-------------------------------------------------------------------------

; ed_shr_mul_result_loop:
;                 lsr ed_mul_result+1
;                 ror ed_mul_result+0
;                 dex
; ed_shr_mul_result:
;                 cpx #0
;                 bne ed_shr_mul_result_loop
;                 rts

;-------------------------------------------------------------------------
;
; Entry: ?ed_mul_a = operand A
;        ?ed_mul_b = operand B
; Exit: 
;
; ed_mul_result.w = result
ed_mul_test:
                stx ed_mul_a
                sty ed_mul_b
                jsr ed_mul_8x8_16
                ldx ed_mul_result+0
                ldy ed_mul_result+1
                rts
                
ed_mul_8x8_16: .proc
                lda ed_mul_a
                sta ed_mul_tempb
                
                lda ed_mul_b
                sta ed_mul_tempw+0
                lda #0
                sta ed_mul_tempw+1

                sta ed_mul_result+0
                sta ed_mul_result+1

                ldx #8
loop:
                lsr ed_mul_tempb
                bcc +
                clc
                lda ed_mul_tempw+0
                adc ed_mul_result+0
                sta ed_mul_result+0
                lda ed_mul_tempw+1
                adc ed_mul_result+1
                sta ed_mul_result+1
+
                asl ed_mul_tempw+0
                rol ed_mul_tempw+1
                dex
                bne loop

                rts
                .endproc

;-------------------------------------------------------------------------
;
; Unsigned 1.7 fixed piont values from $00 (0.0) to $80 (1.0)
; inclusive, in random order. 129 1-byte entries. Generated using Python:

; values=list(range(129));
; random.shuffle(values);
; ','.join(['$%02x'%x for x in values])

ed_random_frac_table: .block
                .byte $61,$23,$6c,$55,$1c,$5a,$77,$39,$31,$4d,$6a,$0c,$1a,$29,$74,$4b,$40,$06,$79,$1e,$7f,$62,$2c,$6f,$17,$32,$66,$73,$50,$26,$70,$48,$58,$0f,$14,$78,$3f,$47,$25,$27,$19,$3b,$0a,$76,$68,$01,$1f,$65,$20,$44,$67,$00,$56,$0b,$43,$71,$3e,$80,$5e,$33,$57,$45,$75,$1d,$4e,$24,$54,$4a,$52,$5f,$21,$5b,$2a,$60,$3c,$51,$22,$38,$4f,$28,$09,$10,$2e,$15,$30,$7a,$35,$53,$6e,$7b,$6d,$04,$34,$4c,$49,$08,$11,$64,$5c,$5d,$12,$41,$36,$03,$16,$6b,$7c,$18,$07,$2d,$46,$42,$0e,$2f,$59,$02,$7e,$7d,$37,$05,$63,$3a,$1b,$2b,$0d,$3d,$69,$13,$72
                .endblock

;-------------------------------------------------------------------------
;
; Ghost addresses, generated by the Python equivalent of
; &6000+RND(300)*16. 128 2-byte entries. Generated using Python:

; ','.join(['$%04x'%(0x6000+random.randrange(301)*16) for i in range(128)])
ed_random_ghost_addr_table: .block
                .word $6280,$6d80,$6d90,$6f00,$6270,$6f80,$7270,$7050,$6d10,$65c0,$6640,$71e0,$6490,$6ec0,$6be0,$6090,$63c0,$61b0,$6e70,$6910,$6a90,$6770,$7100,$7090,$6980,$6580,$6420,$6ae0,$71b0,$72b0,$60a0,$6860,$6350,$6090,$71f0,$6960,$61c0,$6bd0,$6110,$69f0,$6300,$71c0,$6ec0,$6d40,$6170,$6260,$66f0,$6df0,$7070,$6280,$6990,$6f30,$6b80,$6650,$60d0,$6f30,$6d20,$65f0,$7160,$6730,$61f0,$6910,$61b0,$6790,$6890,$70f0,$6030,$70e0,$65e0,$6d60,$6e60,$6820,$69d0,$61e0,$6780,$6410,$6470,$6950,$6440,$6f30,$68c0,$6a40,$6a90,$6530,$6670,$6ac0,$67a0,$7090,$7200,$6c10,$6720,$6170,$6da0,$6970,$6740,$6990,$6d30,$6e50,$63a0,$6150,$6890,$7060,$66f0,$7070,$6150,$7050,$72b0,$63d0,$6110,$6530,$6fa0,$7140,$6320,$6d60,$6da0,$6d20,$6030,$71d0,$6030,$68d0,$6420,$6420,$6330,$61d0,$6180,$69b0,$71e0,$62e0
                .endblock
                
;-------------------------------------------------------------------------
                .endif          ;editor
;-------------------------------------------------------------------------

                .if editor
                .cerror *-gmc_start>max_gedmc_pages*256,"gedmc overflow"
                .else
                .cerror *-gmc_start>max_gmc_pages*256,"gmc overflow"
                .endif
                
